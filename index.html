<!DOCTYPE html>
<html lang="it">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Canzoniere Digitale</title>
    <!-- Riferimento al manifest per la PWA -->
    <link rel="manifest" href="manifest.json">
    <link rel="icon" type="image/png" sizes="32x32" href="icon-32.png">
    <meta name="theme-color" content="#3B82F6">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <link rel="stylesheet" href="./offline-assets/fontawesome.css">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Roboto, -apple-system, BlinkMacSystemFont, sans-serif;
            background: linear-gradient(135deg, #f8fafc 0%, #e2e8f0 100%);
            color: #1e293b;
            overflow-x: hidden;
            user-select: none;
            min-height: 100vh;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
        }

        /* Header */
        .header {
            background: linear-gradient(135deg, #3B82F6, #1d4ed8);
            color: white;
            padding: 20px 0;
            box-shadow: 0 8px 32px rgba(59, 130, 246, 0.3);
            position: sticky;
            top: 0;
            z-index: 100;
            backdrop-filter: blur(10px);
        }

        .header-content {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 0 20px;
        }

        .header h1 {
            font-size: 1.6rem;
            font-weight: 700;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .header-actions {
            display: flex;
            gap: 12px;
        }

        /* Navigation */
        .nav-tabs {
            display: flex;
            background: white;
            border-radius: 16px;
            padding: 6px;
            margin: 24px 0;
            box-shadow: 0 4px 20px rgba(0,0,0,0.08);
            overflow-x: auto;
            border: 1px solid #e2e8f0;
        }

        .nav-tab {
            flex: 1;
            padding: 14px 24px;
            text-align: center;
            border: none;
            background: transparent;
            border-radius: 12px;
            cursor: pointer;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            font-weight: 600;
            white-space: nowrap;
            position: relative;
            color: #64748b;
        }

        .nav-tab.active {
            background: linear-gradient(135deg, #3B82F6, #2563eb);
            color: white;
            box-shadow: 0 4px 16px rgba(59, 130, 246, 0.4);
            transform: translateY(-1px);
        }

        .nav-tab:hover:not(.active) {
            background: #f1f5f9;
            color: #3B82F6;
        }

        /* Tab Content */
        .tab-content {
            display: none; /* Hidden by default */
        }

        .tab-content.active {
            display: block; /* Shown when active */
        }


        /* Cards */
        .card {
            background: white;
            border-radius: 20px;
            padding: 28px;
            margin-bottom: 24px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.06);
            border: 1px solid #e2e8f0;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            position: relative;
            overflow: hidden;
        }

        .card::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 4px;
            background: linear-gradient(90deg, #3B82F6, #14B8A6);
            opacity: 0;
            transition: opacity 0.3s ease;
        }

        .card:hover {
            transform: translateY(-4px);
            box-shadow: 0 12px 40px rgba(0,0,0,0.12);
        }

        .card:hover::before {
            opacity: 1;
        }

        .card-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 24px;
        }

        /* Buttons */
        .btn {
            padding: 12px 24px;
            border: none;
            border-radius: 12px;
            cursor: pointer;
            font-weight: 600;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            display: inline-flex;
            align-items: center;
            gap: 8px;
            text-decoration: none;
            font-size: 14px;
            line-height: 1;
            position: relative;
            overflow: hidden;
        }

        .btn::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255,255,255,0.2), transparent);
            transition: left 0.5s;
        }

        .btn:hover::before {
            left: 100%;
        }

        .btn-primary {
            background: linear-gradient(135deg, #3B82F6, #2563eb);
            color: white;
            box-shadow: 0 4px 16px rgba(59, 130, 246, 0.3);
        }

        .btn-primary:hover {
            background: linear-gradient(135deg, #2563eb, #1d4ed8);
            transform: translateY(-2px);
            box-shadow: 0 8px 24px rgba(59, 130, 246, 0.4);
        }

        .btn-secondary {
            background: #f1f5f9;
            color: #64748b;
            border: 1px solid #e2e8f0;
        }

        .btn-secondary:hover {
            background: #e2e8f0;
            color: #475569;
            transform: translateY(-1px);
        }

        .btn-danger {
            background: linear-gradient(135deg, #ef4444, #dc2626);
            color: white;
            box-shadow: 0 4px 16px rgba(239, 68, 68, 0.3);
        }

        .btn-danger:hover {
            background: linear-gradient(135deg, #dc2626, #b91c1c);
            transform: translateY(-2px);
        }

        .btn-success {
            background: linear-gradient(135deg, #10b981, #059669);
            color: white;
            box-shadow: 0 4px 16px rgba(16, 185, 129, 0.3);
        }

        .btn-success:hover {
            background: linear-gradient(135deg, #059669, #047857);
            transform: translateY(-2px);
        }

        .btn-sm {
            padding: 8px 16px;
            font-size: 12px;
            border-radius: 8px;
        }
        
        .btn-icon {
            width: 36px;
            height: 36px;
            padding: 0;
            justify-content: center;
            font-size: 16px;
            border-radius: 10px;
        }

        /* PDF Viewer */
        .pdf-viewer {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: #000;
            z-index: 1000;
            display: none;
            touch-action: none;
            overflow: hidden;
        }

        .pdf-controls {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            background: linear-gradient(180deg, rgba(0,0,0,0.9) 0%, rgba(0,0,0,0.7) 100%);
            padding: 20px;
            display: flex;
            align-items: center;
            gap: 16px;
            z-index: 1001;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            opacity: 1;
            pointer-events: auto;
            backdrop-filter: blur(10px);
        }

        .pdf-controls.hidden, .pdf-navigation.hidden {
            opacity: 0;
            pointer-events: none;
            transform: translateY(-100%);
        }

        .pdf-search {
            flex: 1;
            padding: 12px 16px;
            border: none;
            border-radius: 12px;
            background: rgba(255,255,255,0.95);
            backdrop-filter: blur(10px);
            font-size: 14px;
            transition: all 0.3s ease;
            min-width: 0; /* Permette alla barra di ricerca di ridursi */
            max-width: 350px; /* Limita la larghezza per non sovrapporsi alla palette */
        }

        .pdf-search:focus {
            outline: none;
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.3);
        }

        /* Stile per il pulsante tavolozza nella barra di controllo */
        .pdf-controls .annotation-toggle {
            width: 40px;
            height: 40px;
            border-radius: 10px;
            background: linear-gradient(135deg, #3B82F6, #2563eb);
            color: white;
            border: none;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 18px;
            box-shadow: 0 4px 16px rgba(59, 130, 246, 0.4);
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            flex-shrink: 0; /* Impedisce al pulsante di ridursi */
        }

        .pdf-controls .annotation-toggle:hover {
            transform: scale(1.1);
            box-shadow: 0 6px 20px rgba(59, 130, 246, 0.6);
        }

        .pdf-controls .annotation-toggle.active {
            background: linear-gradient(135deg, #ef4444, #dc2626);
            box-shadow: 0 4px 16px rgba(239, 68, 68, 0.4);
        }

        .pdf-canvas-container {
            position: absolute;
            top: 80px; /* Adjusted when controls are visible */
            left: 0;
            right: 0;
            bottom: 90px; /* Adjusted when controls are visible */
            display: grid;
            place-items: center;
            overflow: auto;
            touch-action: pan-x pan-y;
            scrollbar-width: thin;
            scrollbar-color: #3B82F6 rgba(255,255,255,0.1);
            transition: all 0.3s ease;
        }
        
        .pdf-canvas-container::-webkit-scrollbar {
            width: 8px;
            height: 8px;
        }
        
        .pdf-canvas-container::-webkit-scrollbar-track {
            background: rgba(255,255,255,0.1);
            border-radius: 4px;
        }
        
        .pdf-canvas-container::-webkit-scrollbar-thumb {
            background: #3B82F6;
            border-radius: 4px;
        }
        
        .pdf-canvas-container::-webkit-scrollbar-thumb:hover {
            background: #2563eb;
        }

        .pdf-canvas {
            display: block;
            user-select: none;
            background: white;
            box-shadow: 0 8px 40px rgba(0,0,0,0.4);
            /* REMOVED max-width and max-height to allow canvas to exceed container for panning */
            border-radius: 8px;
            transition: transform 0.15s cubic-bezier(0.4, 0, 0.2, 1); /* Reduced transition for perceived fluidity */
            position: relative; /* Needed for hyperlink overlays */
        }

         /* Hyperlink Overlay */
        .link-overlay {
            position: absolute;
            background: rgba(59, 130, 246, 0.0); /* Transparent by default */
            transition: background 0.2s ease;
            cursor: pointer;
            z-index: 1004; /* Above canvas, below indicators */
            border-radius: 4px; /* Optional: slightly rounded corners */
        }

        .link-overlay:hover, .link-overlay:active {
            background: rgba(59, 130, 246, 0.2); /* Semi-transparent blue on hover/tap */
        }

        .pdf-navigation {
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            background: linear-gradient(0deg, rgba(0,0,0,0.9) 0%, rgba(0,0,0,0.7) 100%);
            padding: 20px;
            display: flex;
            align-items: center;
            gap: 16px;
            z-index: 1001;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            opacity: 1;
            pointer-events: auto;
            backdrop-filter: blur(10px);
        }

        .pdf-navigation.hidden {
            transform: translateY(100%);
        }

        .page-info-display {
            color: white;
            font-weight: 600;
            font-size: 14px;
            background: rgba(255, 255, 255, 0.1);
            padding: 8px 12px;
            border-radius: 8px;
            backdrop-filter: blur(5px);
            min-width: 60px;
            text-align: center;
            flex-shrink: 0;
        }

        .pdf-slider {
            flex: 1 1 0;
            height: 8px;
            border-radius: 4px;
            background: rgba(255,255,255,0.3);
            outline: none;
            cursor: pointer;
            -webkit-appearance: none;
            appearance: none;
            transition: all 0.3s ease;
            max-width: 100%;
        }
        
        .pdf-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 20px;
            height: 20px;
            background: linear-gradient(135deg, #3B82F6, #2563eb);
            border-radius: 50%;
            cursor: pointer;
            margin-top: -6px;
            box-shadow: 0 2px 8px rgba(59, 130, 246, 0.4);
            transition: all 0.3s ease;
        }

        .pdf-slider::-webkit-slider-thumb:hover {
            transform: scale(1.2);
        }
        
        .pdf-slider::-moz-range-thumb {
            width: 20px;
            height: 20px;
            background: linear-gradient(135deg, #3B82F6, #2563eb);
            border-radius: 50%;
            cursor: pointer;
            border: none;
            box-shadow: 0 2px 8px rgba(59, 130, 246, 0.4);
        }

        /* Swipe Indicators */
        .swipe-indicator {
            position: absolute;
            top: 50%;
            transform: translateY(-50%);
            width: 50px;
            height: 50px;
            background: rgba(0, 0, 0, 0.2);
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-size: 24px;
            z-index: 3001;
            border-radius: 50%;
            backdrop-filter: blur(5px);
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .swipe-indicator:hover {
            background: rgba(0, 0, 0, 0.6);
            transform: translateY(-50%) scale(1.1);
        }

        .swipe-indicator.left {
            left: 20px;
        }

        .swipe-indicator.right {
            right: 20px;
        }

        .swipe-indicator.hidden {
            opacity: 0;
            pointer-events: none;
        }

        .floating-btn {
            position: fixed;
            bottom: 120px;
            right: 30px;
            width: 56px;
            height: 56px;
            border-radius: 50%;
            background: linear-gradient(135deg, #3B82F6, #2563eb);
            color: white;
            border: none;
            cursor: pointer;
            box-shadow: 0 8px 32px rgba(59, 130, 246, 0.4);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 24px;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            z-index: 3001;
        }

        .floating-btn:hover {
            transform: scale(1.1) translateY(-2px);
            box-shadow: 0 12px 40px rgba(59, 130, 246, 0.6);
        }

        .floating-btn:active {
            transform: scale(0.95);
        }

        /* Modal */
        .modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.6);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 2000;
            padding: 20px;
            overflow-y: auto;
            backdrop-filter: blur(8px);
        }

        .modal-content {
            background: white;
            border-radius: 20px;
            padding: 32px;
            max-width: 700px;
            width: 100%;
            max-height: 90vh;
            overflow-y: auto;
            box-shadow: 0 20px 60px rgba(0,0,0,0.3);
            position: relative;
            transform: scale(0.9);
            transition: transform 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        }

        .modal.show .modal-content {
            transform: scale(1);
        }

        .modal h2 {
            margin-bottom: 24px;
            color: #1e293b;
            font-size: 1.5rem;
            font-weight: 700;
        }

        .form-group {
            margin-bottom: 24px;
        }

        .form-group label {
            display: block;
            margin-bottom: 8px;
            font-weight: 600;
            color: #374151;
        }

        .form-group input,
        .form-group textarea {
            width: 100%;
            padding: 14px 16px;
            border: 2px solid #e2e8f0;
            border-radius: 12px;
            font-size: 16px;
            transition: all 0.3s ease;
            background: #f8fafc;
        }

        .form-group input:focus,
        .form-group textarea:focus {
            outline: none;
            border-color: #3B82F6;
            background: white;
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.1);
        }

        /* Event List */
        .event-item {
            display: flex;
            align-items: center;
            justify-content: flex-start;
            padding: 10px 12px;
            border: 2px solid #e2e8f0;
            border-radius: 12px;
            margin-bottom: 8px;
            cursor: pointer;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            background: white;
            position: relative;
            overflow: hidden;
            min-height: 0;
        }
        .event-col-num {
            font-weight: bold;
            color: #3B82F6;
            font-size: 1.1em;
        }
        .event-col-check {
            min-width: 32px;
        }
        .event-col-content {
            min-width: 0;
        }
        .event-col-actions {
            min-width: 80px;
        }
        .reorder-checkbox {
            width: 22px;
            height: 22px;
            border: 2px solid #3B82F6;
            border-radius: 4px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.3s ease;
            background: #fff;
        }
        .reorder-checkbox.checked {
            background: #3B82F6;
            color: white;
        }
        .reorder-checkbox.show {
            visibility: visible !important;
        }

        .event-item::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(59, 130, 246, 0.05), transparent);
            transition: left 0.5s;
        }

        .event-item:hover::before {
            left: 100%;
        }

        .event-item:hover {
            border-color: #3B82F6;
            transform: translateX(8px);
            box-shadow: 0 8px 32px rgba(59, 130, 246, 0.15);
        }

        .event-item.selected {
            border-color: #3B82F6;
            background: linear-gradient(135deg, #eff6ff, #dbeafe);
            box-shadow: 0 4px 20px rgba(59, 130, 246, 0.2);
        }

        .event-info h3 {
            margin-bottom: 2px;
            font-size: 1em;
        }

        .event-info p {
            font-size: 0.85em;
            margin-bottom: 2px;
        }
        
        .event-info small {
            font-size: 0.75em;
        }

        .event-actions {
            display: flex;
            gap: 4px;
            margin-left: auto;
            justify-content: flex-end;
            align-items: center;
            min-width: 80px;
        }

        /* Reorder Controls */
        .reorder-controls {
            display: none;
            align-items: center;
            justify-content: center;
            gap: 0;
            margin-left: 0;
            min-width: 40px;
        }

        .reorder-controls.show {
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        .reorder-checkbox {
            width: 22px;
            height: 22px;
            border: 2px solid #3B82F6;
            border-radius: 4px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.3s ease;
            background: #fff;
        }

        .reorder-checkbox.checked {
            background: #3B82F6;
            color: white;
        }

        .reorder-checkbox.show {
            visibility: visible !important;
        }

        .reorder-buttons {
            display: flex;
            flex-direction: column;
            gap: 4px;
        }

        .reorder-btn {
            width: 28px;
            height: 28px;
            border: none;
            background: #f1f5f9;
            color: #64748b;
            border-radius: 6px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 12px;
            transition: all 0.3s ease;
        }

        .reorder-btn:hover {
            background: #3B82F6;
            color: white;
        }

        .reorder-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        /* Page List */
        .page-list {
            max-height: 400px;
            overflow-y: auto;
            border: 2px solid #e2e8f0;
            border-radius: 12px;
            padding: 12px;
            background: #f8fafc;
        }

        /* Loading */
        .loading {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(255, 255, 255, 0.9);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 3000;
            backdrop-filter: blur(8px);
        }

        .spinner {
            width: 60px;
            height: 60px;
            border: 6px solid #e2e8f0;
            border-top: 6px solid #3B82F6;
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        /* Toast notifications */
        .toast {
            position: fixed;
            top: 20px;
            right: 20px;
            background: linear-gradient(135deg, #10b981, #059669);
            color: white;
            padding: 16px 24px;
            border-radius: 12px;
            box-shadow: 0 8px 32px rgba(16, 185, 129, 0.3);
            z-index: 3000;
            transform: translateX(calc(100% + 20px));
            transition: transform 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            backdrop-filter: blur(10px);
        }

        .toast.show {
            transform: translateX(0);
        }

        .toast.error {
            background: linear-gradient(135deg, #ef4444, #dc2626);
        }
        
        .toast.warning {
            background: linear-gradient(135deg, #f59e0b, #d97706);
        }
        
        .toast.secondary {
            background: linear-gradient(135deg, #64748b, #475569);
        }

        /* Upload Area */
        .upload-area {
            border: 2px dashed #cbd5e1;
            border-radius: 12px;
            padding: 12px 8px;
            text-align: center;
            cursor: pointer;
            background: linear-gradient(135deg, #f8fafc, #f1f5f9);
            position: relative;
            overflow: hidden;
            margin-bottom: 0;
        }
        .upload-icon {
            font-size: 24px;
            color: #94a3b8;
            margin-bottom: 6px;
        }
        .upload-area h3 {
            font-size: 0.95em;
            margin-bottom: 2px;
        }
        .upload-area p, .upload-area small {
            font-size: 0.85em;
            margin-bottom: 0;
        }
        .upload-area:hover {
            border-color: #3B82F6;
            background: linear-gradient(135deg, #eff6ff, #dbeafe);
            transform: none;
        }
        /* Layout PDF section */
        .pdf-section-flex {
            display: flex;
            gap: 16px;
            align-items: flex-start;
        }
        .pdf-upload-col {
            flex: 0 0 260px;
            min-width: 200px;
            max-width: 320px;
        }
        .pdf-list-col {
            flex: 1 1 0;
            min-width: 0;
        }
        .pdf-list-col .card-header h2 {
            font-size: 1.35em;
        }
        .pdf-list-col .card {
            box-shadow: 0 6px 32px rgba(59,130,246,0.10);
            border-width: 2px;
        }
        @media (max-width: 900px) {
            .pdf-section-flex {
                flex-direction: column;
                gap: 12px;
            }
            .pdf-upload-col, .pdf-list-col {
                max-width: 100%;
                width: 100%;
            }
        }

        /* Responsive */
        @media (max-width: 768px) {
            .container {
                padding: 16px;
            }

            .header h1 {
                font-size: 1.4rem;
            }
            
            .header-actions {
                gap: 8px;
            }

            .pdf-controls {
                flex-wrap: wrap;
                gap: 12px;
                padding: 16px;
            }
            
            .pdf-controls .btn, .pdf-controls .btn-sm {
                padding: 10px 14px;
                font-size: 12px;
            }

            .pdf-controls .annotation-toggle {
                width: 36px;
                height: 36px;
                font-size: 16px;
            }

            .pdf-search {
                order: 1;
                width: 100%;
                margin-top: 8px;
            }

            .pdf-navigation {
                padding: 16px;
                gap: 12px;
            }
            
            .pdf-navigation .btn, .pdf-navigation .btn-sm {
                padding: 10px 14px;
                font-size: 12px;
            }

            .modal-content {
                padding: 24px;
                margin: 20px;
            }

            .event-item {
                flex-direction: column;
                align-items: flex-start;
                gap: 6px;
                padding: 8px 6px;
                margin-bottom: 6px;
            }

            .event-actions {
                margin-top: 4px;
            }

            .floating-btn {
                bottom: 100px;
                right: 20px;
                width: 52px;
                height: 52px;
                font-size: 20px;
            }

            .swipe-indicator {
                width: 50px;
                height: 100px;
            }
        }

        /* Install Prompt */
        .install-prompt {
            background: linear-gradient(135deg, #10b981, #059669);
            color: white;
            padding: 20px;
            border-radius: 16px;
            margin-bottom: 24px;
            text-align: center;
            display: flex;
            justify-content: space-between;
            align-items: center;
            gap: 16px;
            flex-wrap: wrap;
            box-shadow: 0 8px 32px rgba(16, 185, 129, 0.3);
        }

        .install-prompt p {
            flex-grow: 1;
            margin: 0;
            font-weight: 500;
        }

        .install-prompt button {
            flex-shrink: 0;
        }

        .install-prompt.hidden {
            display: none;
        }

        /* Empty state */
        .empty-state {
            text-align: center;
            padding: 48px 24px;
            color: #64748b;
        }
        
        .empty-state i {
            font-size: 56px;
            margin-bottom: 20px;
            color: #cbd5e1;
            transition: all 0.3s ease;
        }

        .empty-state:hover i {
            color: #94a3b8;
            transform: scale(1.1);
        }

        /* Zoom Level Indicator */
        .zoom-indicator {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 12px 20px;
            border-radius: 12px;
            font-size: 18px;
            font-weight: 600;
            z-index: 1003;
            opacity: 0;
            transition: opacity 0.3s ease;
            pointer-events: none;
            backdrop-filter: blur(10px);
        }

        .zoom-indicator.show {
            opacity: 1;
        }

        /* Annotation Controls */
        .annotation-controls {
            position: absolute;
            top: 20px;
            right: 20px;
            z-index: 1005;
            display: flex;
            flex-direction: column;
            gap: 8px;
            transition: all 0.3s ease;
        }

        .annotation-toggle {
            width: 48px;
            height: 48px;
            border-radius: 50%;
            background: linear-gradient(135deg, #3B82F6, #2563eb);
            color: white;
            border: none;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 20px;
            box-shadow: 0 4px 16px rgba(59, 130, 246, 0.4);
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            z-index: 1006;
        }

        .annotation-toggle:hover {
            transform: scale(1.1);
            box-shadow: 0 6px 20px rgba(59, 130, 246, 0.6);
        }

        .annotation-toggle.active {
            background: linear-gradient(135deg, #ef4444, #dc2626);
            box-shadow: 0 4px 16px rgba(239, 68, 68, 0.4);
        }

        .annotation-tools {
            display: none;
            flex-direction: column;
            gap: 8px;
            background: rgba(0, 0, 0, 0.8);
            backdrop-filter: blur(10px);
            border-radius: 12px;
            padding: 12px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
        }

        .annotation-tools.show {
            display: flex;
        }

        .annotation-tool {
            width: 40px;
            height: 40px;
            border-radius: 8px;
            border: none;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 16px;
            transition: all 0.3s ease;
            background: rgba(255, 255, 255, 0.1);
            color: white;
        }

        .annotation-tool:hover {
            background: rgba(255, 255, 255, 0.2);
            transform: scale(1.1);
        }

        .annotation-tool.active {
            background: #3B82F6;
            box-shadow: 0 2px 8px rgba(59, 130, 246, 0.4);
        }

        .annotation-tool.pen {
            color: #ef4444;
        }

        .annotation-tool.eraser {
            color: #f59e0b;
        }

        .annotation-tool.note {
            color: #10b981;
        }

        /* Drawing Canvas */
        .drawing-canvas {
            position: absolute;
            top: 0;
            left: 0;
            pointer-events: none;
            z-index: 1004;
        }

        .drawing-canvas.active {
            pointer-events: auto;
        }

        /* Sticky Notes - NUOVO STILE BLU */
        .sticky-note {
            position: absolute;
            min-width: 60px;
            min-height: 32px;
            max-width: 220px;
            background: #e0edff;
            border: 1px solid #2563eb;
            border-radius: 8px;
            padding: 4px 8px 4px 4px;
            cursor: default;
            z-index: 1007;
            box-shadow: 0 2px 8px rgba(59, 130, 246, 0.10);
            font-family: 'Segoe UI', sans-serif;
            font-size: 13px;
            line-height: 1.3;
            resize: none;
            overflow: visible;
            display: flex;
            align-items: flex-start;
            transition: box-shadow 0.2s;
        }
        .sticky-note:focus {
            outline: none;
            border-color: #3B82F6;
            box-shadow: 0 0 0 2px rgba(59, 130, 246, 0.18);
        }
        .sticky-note-header {
            display: flex;
            align-items: center;
            margin: 0;
            padding: 0;
            border: none;
            background: none;
        }
        .sticky-note-close {
            background: #2563eb;
            border: none;
            color: #fff;
            cursor: pointer;
            font-size: 13px;
            width: 22px;
            height: 22px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 5px;
            margin-right: 6px;
            margin-top: 2px;
            margin-bottom: 2px;
            box-shadow: 0 1px 3px rgba(59,130,246,0.10);
            transition: background 0.2s;
        }
        .sticky-note-close:hover {
            background: #1d4ed8;
        }
        .sticky-note-content {
            width: 100%;
            min-height: 22px;
            border: none;
            background: transparent;
            resize: none;
            font-family: inherit;
            font-size: inherit;
            line-height: inherit;
            outline: none;
            padding: 2px 0 2px 0;
            margin: 0;
            color: #1e293b;
            display: inline-block;
        }
        .sticky-note-icons {
            position: absolute;
            width: 100%;
            left: 0;
            top: 0;
            pointer-events: none;
        }
        .sticky-note-move {
            position: absolute;
            top: 2px;
            right: 4px;
            font-size: 16px;
            color: #2563eb;
            background: #e0edff;
            border-radius: 4px;
            padding: 1px 3px;
            cursor: grab;
            pointer-events: auto;
            opacity: 0.85;
            transition: background 0.2s;
        }
        .sticky-note-move:active {
            cursor: grabbing;
            background: #dbeafe;
        }
        .sticky-note-resize {
            position: absolute;
            bottom: 2px;
            right: 2px;
            font-size: 14px;
            color: #2563eb;
            background: #e0edff;
            border-radius: 3px;
            padding: 0 2px;
            width: 20px;
            height: 20px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: sw-resize;
            pointer-events: auto;
            opacity: 0.85;
            box-shadow: 0 1px 2px rgba(59,130,246,0.10);
            transition: background 0.2s;
            z-index: 1008;
        }
        .sticky-note-resize:active {
            background: #dbeafe;
        }
        @media (max-width: 768px) {
            .sticky-note-resize {
                font-size: 12px;
                width: 16px;
                height: 16px;
                padding: 0 1px;
            }
        }
        .sticky-note.active, .sticky-note:focus-within {
            box-shadow: 0 0 0 2px #3B82F6, 0 2px 8px rgba(59, 130, 246, 0.18);
        }
        @media (max-width: 768px) {
            .sticky-note {
                font-size: 12px;
                min-width: 48px;
                max-width: 160px;
                padding: 3px 5px 3px 3px;
            }
            .sticky-note-close {
                width: 20px;
                height: 20px;
                font-size: 12px;
            }
            .sticky-note-move, .sticky-note-resize {
                font-size: 15px;
                padding: 0 1px;
            }
        }

        /* Page transition effects */
        .page-transition {
            transition: transform 0.3s cubic-bezier(0.4, 0, 0.2, 1), opacity 0.3s ease;
        }

        .page-transition.slide-left {
            transform: translateX(-100%);
            opacity: 0;
        }

        .page-transition.slide-right {
            transform: translateX(100%);
            opacity: 0;
        }

        /* Custom scrollbar for page list */
        .page-list::-webkit-scrollbar {
            width: 8px;
        }

        .page-list::-webkit-scrollbar-track {
            background: #f1f5f9;
            border-radius: 4px;
        }

        .page-list::-webkit-scrollbar-thumb {
            background: #cbd5e1;
            border-radius: 4px;
        }

        .page-list::-webkit-scrollbar-thumb:hover {
            background: #94a3b8;
        }

        .event-item-number {
            min-width: 26px;
            height: 26px;
            font-size: 0.95em;
            margin-right: 10px;
        }

        .pdf-controls .btn#closePdfBtn {
            padding: 12px 20px;
            font-size: 1em;
            height: auto;
            border-radius: 12px;
        }

        /* Search functionality */
        .search-results {
            position: absolute;
            top: 80px;
            right: 20px;
            background: rgba(0, 0, 0, 0.9);
            backdrop-filter: blur(10px);
            border-radius: 12px;
            padding: 16px;
            max-width: 300px;
            max-height: 400px;
            overflow-y: auto;
            z-index: 1002;
            display: none;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
            pointer-events: auto;
            touch-action: manipulation;
            -webkit-touch-callout: none;
            -webkit-user-select: none;
            -khtml-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            user-select: none;
            scrollbar-width: auto;
            scrollbar-color: #000000 #ffffff;
        }

        .search-results::-webkit-scrollbar {
            width: 16px; /* Più larga su desktop */
            -webkit-appearance: none;
        }

        .search-results::-webkit-scrollbar-track {
            background: #ffffff;
            border-radius: 8px;
            border: 1px solid #e0e0e0;
        }

        .search-results::-webkit-scrollbar-thumb {
            background: #000000;
            border-radius: 8px;
            border: 2px solid #ffffff;
            min-height: 30px;
        }

        .search-results::-webkit-scrollbar-thumb:hover {
            background: #333333;
        }

        .search-results.show {
            display: block;
        }

        .search-result-item {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 8px;
            padding: 12px;
            margin-bottom: 8px;
            cursor: pointer;
            transition: all 0.3s ease;
            border-left: 3px solid transparent;
            -webkit-tap-highlight-color: rgba(59, 130, 246, 0.3);
            touch-action: manipulation;
            user-select: none;
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            pointer-events: auto;
            -webkit-touch-callout: none;
            -webkit-user-select: none;
            -khtml-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            user-select: none;
        }

        .search-result-item:hover {
            background: rgba(255, 255, 255, 0.2);
            border-left-color: #3B82F6;
            transform: translateX(4px);
        }

        .search-result-item:active {
            background: rgba(59, 130, 246, 0.3);
            transform: scale(0.98);
        }

        .search-result-item.active {
            background: rgba(59, 130, 246, 0.3);
            border-left-color: #3B82F6;
        }

        .search-result-page {
            font-size: 12px;
            color: #94a3b8;
            margin-bottom: 4px;
        }

        .search-result-text {
            font-size: 14px;
            color: white;
            line-height: 1.4;
        }

        .search-result-text .highlight {
            background: #fbbf24;
            color: #1e293b;
            padding: 1px 2px;
            border-radius: 2px;
            font-weight: 600;
        }

        .search-navigation {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-top: 12px;
            padding-top: 12px;
            border-top: 1px solid rgba(255, 255, 255, 0.2);
        }

        .search-count {
            color: #94a3b8;
            font-size: 12px;
            flex: 1;
        }

        .search-nav-btn {
            width: 32px;
            height: 32px;
            border: none;
            background: rgba(255, 255, 255, 0.1);
            color: white;
            border-radius: 6px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 12px;
            transition: all 0.3s ease;
        }

        .search-nav-btn:hover {
            background: rgba(255, 255, 255, 0.2);
        }

        .search-nav-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .search-loading {
            color: #94a3b8;
            font-size: 12px;
            text-align: center;
            padding: 20px;
        }

        .search-no-results {
            color: #94a3b8;
            font-size: 12px;
            text-align: center;
            padding: 20px;
        }

        /* Text highlight overlay */
        .text-highlight {
            position: absolute;
            background: rgba(251, 191, 36, 0.3);
            border: 2px solid #fbbf24;
            border-radius: 2px;
            pointer-events: none;
            z-index: 1003;
            transition: all 0.2s ease;
        }

        .text-highlight.active {
            background: rgba(251, 191, 36, 0.6);
            border-color: #f59e0b;
            box-shadow: 0 0 8px rgba(251, 191, 36, 0.5);
        }

        /* Search input improvements */
        .pdf-search {
            flex: 1;
            padding: 12px 16px;
            border: none;
            border-radius: 12px;
            background: rgba(255,255,255,0.95);
            backdrop-filter: blur(10px);
            font-size: 14px;
            transition: all 0.3s ease;
            min-width: 0;
            max-width: 350px;
        }

        .pdf-search:focus {
            outline: none;
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.3);
            background: white;
        }

        .pdf-search.searching {
            background: rgba(251, 191, 36, 0.1);
            border: 2px solid #fbbf24;
        }

        /* Search clear button */
        .search-clear {
            position: absolute;
            right: 12px;
            top: 50%;
            transform: translateY(-50%);
            background: none;
            border: none;
            color: #64748b;
            cursor: pointer;
            padding: 4px;
            border-radius: 4px;
            display: none;
        }

        .search-clear:hover {
            background: rgba(0, 0, 0, 0.1);
            color: #ef4444;
        }

        .search-clear.show {
            display: block;
        }

        .pdf-search-container {
            position: relative;
            flex: 1;
            max-width: 350px;
            display: flex;
            align-items: center;
        }
        .pdf-search {
            width: 100%;
            padding-right: 38px; /* Spazio per la X */
        }
        .search-clear {
            position: absolute;
            right: 8px;
            top: 50%;
            transform: translateY(-50%);
            background: rgba(0,0,0,0.08);
            border: none;
            border-radius: 50%;
            width: 28px;
            height: 28px;
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 2;
            cursor: pointer;
            transition: background 0.2s;
        }
        .search-clear.show {
            display: flex;
        }
        .search-clear i {
            color: #333;
            font-size: 18px;
        }
        @media (max-width: 768px) and (orientation: portrait) {
            .pdf-search-container {
                max-width: 210px;
                min-width: 0;
                width: 100%;
            }
            .pdf-search {
                font-size: 15px;
                padding-right: 38px;
                min-width: 0;
            }
            .search-clear {
                right: 8px;
                width: 28px;
                height: 28px;
            }
        }

        /* Responsive adjustments for mobile portrait - ONLY when search is active */
        @media (max-width: 768px) and (orientation: portrait) {
            .search-results.show {
                position: fixed;
                top: 32%;
                left: 50%;
                transform: translate(-50%, 0);
                width: 90vw;
                max-height: 60vh;
                z-index: 2000;
                padding: 0;
                overflow: hidden;
                display: flex;
                flex-direction: column;
                background: transparent;
                border-radius: 16px;
                box-shadow: none;
                border: 1.5px solid #111;
            }
            .search-results.show #searchResultsList {
                flex: 1;
                overflow-y: auto;
                -webkit-overflow-scrolling: touch;
                padding: 20px;
                padding-top: 60px;
                padding-bottom: 20px;
                padding-right: 25px;
                scrollbar-width: auto;
                scrollbar-color: #000000 #ffffff;
                -webkit-overflow-scrolling: auto;
                overflow-scrolling: auto;
                overflow-y: scroll !important;
                background: transparent;
            }
            .search-results.show .search-result-item {
                padding: 16px;
                margin-bottom: 12px;
                min-height: 70px;
                display: flex;
                flex-direction: column;
                justify-content: center;
                background: rgba(255, 255, 255, 0.7);
                border-radius: 8px;
                border-left: 3px solid transparent;
                transition: all 0.3s ease;
                touch-action: pan-y;
                -webkit-touch-callout: none;
                -webkit-user-select: none;
                user-select: none;
                box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
                backdrop-filter: blur(5px);
            }
            .search-results.show .search-result-item:hover,
            .search-results.show .search-result-item.active {
                background: rgba(255, 255, 255, 0.9);
                border-left-color: #3B82F6;
                transform: translateX(4px);
                box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2);
            }
            .search-results.show .search-result-page {
                font-size: 12px;
                color: #374151;
                margin-bottom: 6px;
                font-weight: 600;
            }
            .search-results.show .search-result-text {
                font-size: 14px;
                color: #1f2937;
                line-height: 1.4;
                font-weight: 500;
            }
            /* Header fisso con pulsante di chiusura e contatore */
            .search-results.show::before {
                content: '';
                position: absolute;
                top: 0;
                left: 0;
                right: 0;
                height: 60px;
                background: transparent;
                z-index: 2001;
                pointer-events: none;
                border-radius: 16px 16px 0 0;
            }
            .search-results.show .search-count {
                position: absolute;
                top: 16px;
                right: 56px;
                color: #111;
                font-size: 18px;
                font-weight: 700;
                z-index: 2003;
                background: rgba(255,255,255,0.95);
                padding: 6px 14px;
                border-radius: 8px;
                box-shadow: 0 2px 6px rgba(0,0,0,0.12);
                border: 1px solid rgba(0,0,0,0.08);
                display: flex;
                align-items: center;
            }
            .search-results.show::after {
                content: '×';
                position: absolute;
                top: 15px;
                right: 15px;
                color: white;
                font-size: 28px;
                font-weight: bold;
                cursor: pointer;
                z-index: 2004;
                width: 36px;
                height: 36px;
                display: flex;
                align-items: center;
                justify-content: center;
                background: rgba(239, 68, 68, 0.95);
                border-radius: 50%;
                pointer-events: auto;
                box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
                border: 1.5px solid rgba(255, 255, 255, 0.3);
                transition: all 0.3s ease;
            }
            .search-results.show::after:hover {
                background: rgba(220, 38, 38, 1);
                transform: scale(1.1);
            }
        }

        /* Responsive adjustments for mobile landscape - ONLY when search is active */
        @media (max-width: 768px) and (orientation: landscape) {
            .search-results.show {
                position: fixed;
                top: 10px;
                left: 10px;
                width: 350px;
                max-height: calc(100vh - 20px);
                z-index: 2000;
                padding: 0;
                overflow: hidden;
                display: flex;
                flex-direction: column;
                background: transparent;
                border-radius: 12px;
                box-shadow: none;
                border: 1.5px solid #111; /* Bordo nero sottile */
            }
            
            .search-results.show .search-loading,
            .search-results.show .search-no-results {
                flex: 1;
                display: flex;
                align-items: center;
                justify-content: center;
                padding: 20px;
            }
            
            .search-results.show #searchResultsList {
                flex: 1;
                overflow-y: auto;
                -webkit-overflow-scrolling: touch;
                padding: 15px;
                padding-top: 50px;
                padding-bottom: 15px;
                padding-right: 25px; /* Spazio extra per la scrollbar larga */
                scrollbar-width: auto;
                scrollbar-color: #000000 #ffffff;
                /* Forza la visualizzazione della scrollbar su mobile */
                -webkit-overflow-scrolling: auto;
                overflow-scrolling: auto;
                /* Forza la scrollbar a essere sempre visibile */
                overflow-y: scroll !important;
                background: transparent; /* Sfondo completamente trasparente */
            }
            
            .search-results.show #searchResultsList::-webkit-scrollbar {
                width: 20px; /* Molto più larga */
                -webkit-appearance: none;
                display: block !important;
            }
            
            .search-results.show #searchResultsList::-webkit-scrollbar-track {
                background: #ffffff;
                border-radius: 10px;
                margin: 5px 0;
                border: 1px solid #e0e0e0;
                display: block !important;
            }
            
            .search-results.show #searchResultsList::-webkit-scrollbar-thumb {
                background: #000000;
                border-radius: 10px;
                border: 2px solid #ffffff;
                min-height: 40px;
                display: block !important;
            }
            
            .search-results.show #searchResultsList::-webkit-scrollbar-thumb:hover {
                background: #333333;
            }
            
            .search-results.show .search-result-item {
                padding: 12px;
                margin-bottom: 8px;
                min-height: 60px;
                display: flex;
                flex-direction: column;
                justify-content: center;
                background: rgba(255, 255, 255, 0.7); /* Celle semi-opache (traslucide) */
                border-radius: 6px;
                border-left: 3px solid transparent;
                transition: all 0.3s ease;
                /* Migliora il touch */
                touch-action: pan-y;
                -webkit-touch-callout: none;
                -webkit-user-select: none;
                user-select: none;
                box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
                backdrop-filter: blur(5px);
            }
            
            .search-results.show .search-result-item:hover,
            .search-results.show .search-result-item.active {
                background: rgba(255, 255, 255, 0.9); /* Più opaco al hover */
                border-left-color: #3B82F6;
                transform: translateX(4px);
                box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2);
            }
            
            .search-results.show .search-result-page {
                font-size: 11px;
                color: #374151; /* Grigio scuro per contrasto */
                margin-bottom: 4px;
                font-weight: 600;
            }
            
            .search-results.show .search-result-text {
                font-size: 13px;
                color: #1f2937; /* Grigio molto scuro per massimo contrasto */
                line-height: 1.3;
                font-weight: 500;
            }
            
            /* Header fisso con pulsante di chiusura */
            .search-results.show::before {
                content: '';
                position: absolute;
                top: 0;
                left: 0;
                right: 0;
                height: 50px;
                background: rgba(255, 255, 255, 0.8); /* Header semi-trasparente */
                z-index: 2001;
                pointer-events: none;
                border-radius: 12px 12px 0 0;
                backdrop-filter: blur(10px);
            }
            
            /* Pulsante di chiusura fisso */
            .search-results.show::after {
                content: '×';
                position: absolute;
                top: 12px;
                right: 12px;
                color: white;
                font-size: 20px;
                font-weight: bold;
                cursor: pointer;
                z-index: 2002;
                width: 26px;
                height: 26px;
                display: flex;
                align-items: center;
                justify-content: center;
                background: rgba(239, 68, 68, 0.9);
                border-radius: 50%;
                pointer-events: auto;
                box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
                border: 1px solid rgba(255, 255, 255, 0.3);
                transition: all 0.3s ease;
            }
            
            .search-results.show::after:hover {
                background: rgba(220, 38, 38, 1);
                transform: scale(1.1);
            }
            
            /* Nascondi la navigation con i pulsanti freccia */
            .search-results.show .search-navigation {
                display: none !important;
            }
            
            /* Contatore risultati sempre visibile in alto */
            .search-results.show .search-count {
                position: absolute;
                top: 15px;
                left: 15px;
                color: #1f2937; /* Grigio scuro per contrasto */
                font-size: 12px;
                font-weight: 600;
                z-index: 2002;
                background: rgba(255, 255, 255, 0.95); /* Sfondo più opaco per leggibilità */
                padding: 3px 6px;
                border-radius: 4px;
                box-shadow: 0 2px 6px rgba(0, 0, 0, 0.2);
                border: 1px solid rgba(0, 0, 0, 0.1);
            }
        }

        /* Istruzione per ricentrare */
        .recenter-hint {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0,0,0,0.8);
            color: white;
            padding: 8px 16px;
            border-radius: 20px;
            font-size: 12px;
            z-index: 1000;
            opacity: 0;
            transition: opacity 0.3s;
            pointer-events: none;
        }

        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.5);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 1000;
            backdrop-filter: blur(5px);
        }
        
        .modal-content {
            background: white;
            border-radius: 16px;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
            max-width: 600px;
            width: 90%;
            max-height: 80vh;
            overflow: hidden;
            animation: modalSlideIn 0.3s ease-out;
        }
        
        @keyframes modalSlideIn {
            from {
                opacity: 0;
                transform: translateY(-20px) scale(0.95);
            }
            to {
                opacity: 1;
                transform: translateY(0) scale(1);
            }
        }
        
        .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 20px 24px;
            border-bottom: 1px solid #e2e8f0;
            background: linear-gradient(135deg, #3B82F6, #2563eb);
            color: white;
        }
        
        .modal-header h3 {
            margin: 0;
            font-size: 1.2rem;
            font-weight: 600;
        }
        
        .modal-close {
            background: none;
            border: none;
            color: white;
            font-size: 1.2rem;
            cursor: pointer;
            padding: 8px;
            border-radius: 8px;
            transition: background 0.2s;
        }
        
        .modal-close:hover {
            background: rgba(255, 255, 255, 0.1);
        }
        
        .modal-body {
            padding: 24px;
            max-height: 60vh;
            overflow-y: auto;
        }
        
        .annotations-list {
            display: flex;
            flex-direction: column;
            gap: 12px;
        }
        
        .annotation-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 16px;
            background: #f8fafc;
            border-radius: 12px;
            border: 1px solid #e2e8f0;
            transition: all 0.2s;
        }
        
        .annotation-item:hover {
            background: #f1f5f9;
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
        }
        
        .annotation-info {
            display: flex;
            flex-direction: column;
            gap: 4px;
        }
        
        .page-number {
            font-weight: 600;
            color: #1e293b;
            font-size: 1rem;
        }
        
        .annotation-types {
            color: #64748b;
            font-size: 0.9rem;
        }
        
        .annotation-actions {
            display: flex;
            gap: 8px;
        }
        
        .btn-sm {
            padding: 8px 12px;
            font-size: 0.85rem;
        }

        @media (max-width: 600px) {
            .pdf-controls .btn.btn-secondary.btn-sm {
                padding: 0 8px;
                min-width: 36px;
                font-size: 0;
                margin-right: 4px;
            }
            .pdf-controls .btn.btn-secondary.btn-sm i {
                font-size: 18px;
                margin-right: 0;
            }
            .pdf-search-container {
                max-width: 120px;
            }
        }
        /* Mostra solo icona nei pulsanti Annotazioni e Indicizza PDF su mobile */
        @media (max-width: 600px) {
            #showAnnotationsListBtn span,
            #indexCurrentPdfBtn span {
                display: none;
            }
        }

        /* Lista pagine evento scrollabile e pulsanti sempre visibili */
        #eventPagesList {
            max-height: 40vh;
            overflow-y: auto;
            margin-bottom: 12px;
            padding-bottom: 80px; /* Spazio per i pulsanti sticky */
        }
        @media (max-width: 600px) {
            #eventPagesList {
                max-height: 30vh;
                margin-bottom: 8px;
                padding-bottom: 70px; /* Meno spazio su mobile */
            }
            .event-detail-header {
                padding-bottom: 0;
            }
            .event-detail-actions {
                margin-top: 8px !important;
            }
            .modal-content {
                padding: 12px !important;
            }
        }
        /* Pulsanti fissi in fondo alla modale evento - sticky perfetto a fondo */
        #eventDetailModal .modal-content {
            padding-bottom: 0 !important;
            border-bottom-left-radius: 16px !important;
            border-bottom-right-radius: 16px !important;
        }
        #eventDetailModal .modal-content > div:last-child {
            position: sticky;
            left: 0;
            right: 0;
            bottom: 0;
            width: 100%;
            background: white;
            z-index: 2;
            padding: 8px 0 20px 0;
            margin-top: 12px !important;
            border-top: 1px solid #e0e0e0;
            border-bottom-left-radius: 16px;
            border-bottom-right-radius: 16px;
            display: flex;
            justify-content: center;
            gap: 12px;
        }
        #eventPagesList {
            max-height: 40vh;
            overflow-y: auto;
            margin-bottom: 8px;
            padding-bottom: 40px;
        }
        #eventPagesList .page-list-item {
            border-radius: 12px;
            margin-bottom: 10px;
            padding: 12px 16px;
            background: #f9fafb;
            box-shadow: 0 1px 3px rgba(0,0,0,0.04);
            display: flex;
            align-items: center;
            justify-content: space-between;
        }
        #eventPagesList .page-list-item:last-child {
            margin-bottom: 0;
        }
        .event-detail-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 16px;
        }
        .event-detail-actions {
            display: flex;
            gap: 8px;
            flex-wrap: wrap;
            margin-top: 0;
        }
        @media (max-width: 600px) {
            #eventPagesList {
                max-height: 30vh;
                margin-bottom: 8px;
                padding-bottom: 30px;
            }
            #eventDetailModal .modal-content > div:last-child {
                flex-direction: column;
                gap: 8px;
            }
        }

        /* Feedback visivo pulsante esporta dati */
        #exportDataBtn {
            transition: all 0.1s ease;
        }
        #exportDataBtn.pressed {
            transform: scale(0.95);
            opacity: 0.8;
            background-color: #198754 !important;
        }
        #exportDataBtn:not(.pressed) {
            transform: scale(1);
            opacity: 1;
        }
        
        /* Barra di progresso esportazione PDF evento */
        #pdfExportProgressBarWrapper {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            z-index: 4000;
            background: rgba(0,0,0,0.15);
            height: 8px;
            display: none;
        }
        #pdfExportProgressBar {
            height: 100%;
            width: 0%;
            background: linear-gradient(90deg, #10b981, #3B82F6);
            transition: width 0.3s;
        }
    </style>
</head>
<body>
    <div id="app">
        <!-- Install Prompt -->
        <div id="installPrompt" class="install-prompt hidden">
            <p>Installa l'app per un accesso più veloce e funzionalità offline!</p>
            <button id="installBtn" class="btn btn-success btn-sm">
                <i class="fas fa-download"></i> Installa App
            </button>
        </div>

        <!-- Header -->
        <header class="header">
            <div class="header-content">
                <h1><i class="fas fa-music"></i> Chora Planner</h1>
                <div class="header-actions">
                    <button class="btn btn-secondary btn-sm" id="refreshBtn" title="Aggiorna">
                        <i class="fas fa-sync-alt"></i>
                    </button>
                    <button class="btn btn-secondary btn-sm" id="helpBtn" title="Aiuto">
                        <i class="fas fa-question-circle"></i>
                    </button>
                </div>
            </div>
        </header>

        <div class="container">
            <div style="display: flex; gap: 16px; justify-content: flex-end; margin-bottom: 16px;">
                <button class="btn btn-success" id="exportDataBtn"><i class="fas fa-upload"></i> Esporta dati</button>
                <button class="btn btn-secondary" id="importDataBtn"><i class="fas fa-download"></i> Importa dati</button>
                <input type="file" id="importDataInput" accept=".json,.zip" style="display:none;" />
            </div>
            <!-- Navigation -->
            <div class="nav-tabs">
                <button class="nav-tab active" data-tab="pdfs">
                    <i class="fas fa-file-pdf"></i> PDF
                </button>
                <button class="nav-tab" data-tab="events">
                    <i class="fas fa-calendar-alt"></i> Eventi
                </button>
            </div>

            <!-- PDF Tab -->
            <div id="pdfs-tab" class="tab-content active">
                <div class="pdf-section-flex">
                    <div class="pdf-upload-col">
                        <div class="card">
                            <div class="card-header" style="margin-bottom: 10px;">
                                <h2 style="font-size:1.1em;"><i class="fas fa-cloud-upload-alt"></i> Carica PDF</h2>
                                <div class="progress-container hidden" id="uploadProgress">
                                    <div class="progress-bar" id="progressBar"></div>
                                </div>
                            </div>
                            <div class="upload-area" id="uploadArea">
                                <div>
                                    <div class="upload-icon">
                                        <i class="fas fa-cloud-upload-alt"></i>
                                    </div>
                                    <h3>Trascina qui il file PDF</h3>
                                    <p>oppure clicca</p>
                                    <small>Max 50MB</small>
                                </div>
                                <input type="file" id="pdfInput" accept=".pdf" style="display: none;">
                            </div>
                            <div style="margin-top: 12px;">
                                <button class="btn btn-secondary btn-sm" id="reindexPdfsBtn" style="width: 100%;">
                                    <i class="fas fa-search"></i> Ricostruisci Indice Ricerca
                                </button>
                            </div>
                        </div>
                    </div>
                    <div class="pdf-list-col">
                        <div class="card">
                            <div class="card-header" style="display: flex; align-items: center; justify-content: space-between;">
                                <h2><i class="fas fa-folder-open"></i> PDF Caricati</h2>
                                <button class="btn btn-secondary btn-sm" id="cleanAnnotationsBtn" title="Pulisci tutte le annotazioni (note e schizzi)">
                                    <i class="fas fa-eraser"></i> Pulisci annotazioni
                                </button>
                            </div>
                            <div id="pdfList">
                                <div class="empty-state">
                                    <i class="fas fa-file-pdf"></i>
                                    <h3>Nessun PDF caricato</h3>
                                    <p>Carica il tuo primo PDF per iniziare</p>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Events Tab -->
            <div id="events-tab" class="tab-content">
                <div class="card">
                    <div class="card-header">
                        <h2><i class="fas fa-music"></i> I Tuoi Eventi</h2>
                        <button class="btn btn-primary" id="createEventBtn">
                            <i class="fas fa-plus"></i> Nuovo Evento
                        </button>
                    </div>
                    <div id="eventsList">
                        <div class="empty-state">
                            <i class="fas fa-calendar-alt"></i>
                            <h3>Nessun evento creato</h3>
                            <p>Crea il tuo primo evento per organizzare le scalette</p>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- PDF Viewer -->
        <div id="pdfViewer" class="pdf-viewer">
            <!-- Swipe Indicators -->
            <div class="swipe-indicator left" id="swipeLeft">
                <i class="fas fa-chevron-left"></i>
            </div>
            <div class="swipe-indicator right" id="swipeRight">
                <i class="fas fa-chevron-right"></i>
            </div>

            <!-- Zoom Indicator -->
            <div class="zoom-indicator" id="zoomIndicator">100%</div>

            <div class="pdf-controls" id="pdfControls">
                <button class="btn btn-secondary btn-sm" id="closePdfBtn">
                    <i class="fas fa-times"></i> Esci
                </button>
                <div class="pdf-search-container">
                    <input type="text" class="pdf-search" id="pdfSearch" placeholder="Cerca nel PDF...">
                    <button class="search-clear" id="searchClear" title="Cancella ricerca">
                        <i class="fas fa-times"></i>
                    </button>
                </div>
                <button class="btn btn-secondary btn-sm" id="showAnnotationsListBtn" title="Mostra pagine con annotazioni">
                    <i class="fas fa-sticky-note"></i> <span>Annotazioni</span>
                </button>
                <button class="btn btn-secondary btn-sm" id="indexCurrentPdfBtn" title="Indicizza solo questo PDF">
                    <i class="fas fa-search"></i> <span>Indicizza PDF</span>
                </button>
            </div>

            <!-- Search Results Panel -->
            <div class="search-results" id="searchResults">
                <div class="search-loading" id="searchLoading" style="display: none;">
                    <i class="fas fa-spinner fa-spin"></i> Ricerca in corso...
                </div>
                <div class="search-no-results" id="searchNoResults" style="display: none;">
                    <i class="fas fa-search"></i> Nessun risultato trovato
                </div>
                <div id="searchResultsList"></div>
                <div class="search-navigation" id="searchNavigation" style="display: none;">
                    <div class="search-count" id="searchCount"></div>
                    <button class="search-nav-btn" id="searchPrevBtn" title="Risultato precedente">
                        <i class="fas fa-chevron-up"></i>
                    </button>
                    <button class="search-nav-btn" id="searchNextBtn" title="Risultato successivo">
                        <i class="fas fa-chevron-down"></i>
                    </button>
                </div>
            </div>

            <div class="pdf-canvas-container" id="pdfCanvasContainer">
                <div id="pdfContentWrapper" style="position: relative;">
                    <canvas id="pdfCanvas" class="page-transition"></canvas>
                    <canvas id="drawingCanvas" class="drawing-canvas"></canvas>
                    <div id="linkOverlays" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: auto;"></div>
                    <div id="stickyNotesContainer" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none;"></div>
                    <div id="textHighlightsContainer" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none;"></div>
                </div>
            </div>

            <!-- Annotation Controls -->
            <div class="annotation-controls" id="annotationControls">
                <button class="annotation-toggle" id="annotationToggle" title="Strumenti di annotazione">
                    <i class="fas fa-palette"></i>
                </button>
                <div class="annotation-tools" id="annotationTools">
                    <button class="annotation-tool pen" id="penTool" title="Penna rossa">
                        <i class="fas fa-pen"></i>
                    </button>
                    <button class="annotation-tool eraser" id="eraserTool" title="Cancella ultima riga">
                        <i class="fas fa-eraser"></i>
                    </button>
                    <button class="annotation-tool note" id="noteTool" title="Aggiungi nota">
                        <i class="fas fa-sticky-note"></i>
                    </button>
                </div>
            </div>

            <div class="pdf-navigation" id="pdfNavigation">
                <div class="page-info-display" id="pageInfoDisplay">1 / 1</div>
                <input type="range" class="pdf-slider" id="pageSlider" min="1" max="1" value="1" style="flex: 1 1 0; max-width: 100%;">
            </div>

            <!-- Istruzione per ricentrare -->
            <div class="recenter-hint" id="recenterHint" style="position: fixed; bottom: 20px; left: 50%; transform: translateX(-50%); background: rgba(0,0,0,0.8); color: white; padding: 8px 16px; border-radius: 20px; font-size: 12px; z-index: 1000; opacity: 0; transition: opacity 0.3s; pointer-events: none;">
                <i class="fas fa-hand-pointer"></i> Tap con 2 dita per ricentrare
            </div>

            <button class="floating-btn" id="addToEventBtn" title="Aggiungi a evento">
                <i class="fas fa-plus"></i>
            </button>
        </div>

        <!-- Modals -->
        <div id="eventModal" class="modal">
            <div class="modal-content">
                <h2 id="eventModalTitle">Nuovo Evento</h2>
                <form id="eventForm">
                    <div class="form-group">
                        <label for="eventName">Nome Evento</label>
                        <input type="text" id="eventName" required placeholder="Inserisci il nome dell'evento">
                    </div>
                    <div class="form-group">
                        <label for="eventDescription">Descrizione</label>
                        <textarea id="eventDescription" rows="3" placeholder="Descrizione opzionale dell'evento"></textarea>
                    </div>
                    <div class="form-group">
                        <label for="eventColor">Colore Tema</label>
                        <input type="color" id="eventColor" value="#3B82F6">
                    </div>
                    <div style="display: flex; gap: 12px; justify-content: flex-end; margin-top: 24px;">
                        <button type="button" class="btn btn-secondary" id="cancelEventBtn">Annulla</button>
                        <button type="submit" class="btn btn-primary">
                            <i class="fas fa-save"></i> Salva
                        </button>
                    </div>
                </form>
            </div>
        </div>

        <div id="eventDetailModal" class="modal">
            <div class="modal-content">
                <div class="event-detail-header">
                    <h2 id="eventDetailTitle">Dettagli Evento</h2>
                    <div class="event-detail-actions" style="display: flex; gap: 8px; flex-wrap: wrap; margin-top: 16px;">
                        <button class="btn btn-secondary btn-sm" id="toggleReorderBtn">
                            <i class="fas fa-sort"></i> Cambia Ordine
                        </button>
                        <button class="btn btn-danger btn-sm" id="deleteEventBtn">
                            <i class="fas fa-trash"></i> Elimina
                        </button>
                        <!-- Spostato il pulsante Visualizza Scaletta in basso -->
                    </div>
                </div>
                <div class="form-group">
                    <label>Scaletta Pagine</label>
                    <div id="eventPagesList" class="page-list">
                        <div class="empty-state">
                            <i class="fas fa-file-alt"></i>
                            <h3>Nessuna pagina aggiunta</h3>
                            <p>Apri un PDF e clicca sul tasto + per aggiungere pagine</p>
                        </div>
                    </div>
                </div>
                <div style="display: flex; gap: 12px; justify-content: flex-end; margin-top: 24px; flex-wrap: wrap;">
                    <button class="btn btn-success" id="exportEventBtn">
                        <i class="fas fa-file-export"></i> Esporta PDF
                    </button>
                    <button class="btn btn-success" id="viewEventBtn">
                        <i class="fas fa-play"></i> Visualizza Scaletta
                    </button>
                    <button class="btn btn-secondary" id="closeEventDetailBtn">Chiudi</button>
                </div>
            </div>
        </div>

        <div id="addPageModal" class="modal">
            <div class="modal-content">
                <h2>Aggiungi Pagina a Evento</h2>
                <div id="eventSelectList"></div>
                <div class="button-group" style="display: flex; gap: 12px; justify-content: flex-end; margin-top: 24px; flex-wrap: wrap;">
                    <button class="btn btn-primary" id="createEventFromAddPageBtn">
                        <i class="fas fa-plus"></i> Crea Nuovo Evento
                    </button>
                    <button class="btn btn-secondary" id="cancelAddPageBtn">Annulla</button>
                </div>
            </div>
        </div>

        <!-- Help Modal -->
        <div id="helpModal" class="modal">
            <div class="modal-content">
                <h2><i class="fas fa-question-circle"></i> Aiuto & Informazioni</h2>
                <p style="margin-bottom: 16px;"><strong>Chora Planner</strong> è un'app per gestire e visualizzare le tue raccolte di canti in formato PDF.</p>
                
                <div class="form-group" style="text-align: left;">
                    <h4 style="margin-bottom: 12px;">Funzionalità Principali:</h4>
                    <ul style="list-style-position: inside; padding-left: 0; margin-left: 0;">
                        <li style="margin-bottom: 8px;"><strong>Carica PDF:</strong> Aggiungi i tuoi canzonieri dall'archivio del tuo dispositivo.</li>
                        <li style="margin-bottom: 8px;"><strong>Crea Eventi:</strong> Organizza scalette personalizzate selezionando pagine specifiche dai tuoi PDF.</li>
                        <li style="margin-bottom: 8px;"><strong>Visualizzatore PDF:</strong> Naviga tra le pagine con swipe, pinch-to-zoom o i controlli a schermo. Clicca al centro per mostrare/nascondere i controlli.</li>
                        <li style="margin-bottom: 8px;"><strong>Modalità Offline:</strong> Una volta caricata, l'app funziona anche senza connessione a internet.</li>
                        <li style="margin-bottom: 8px;"><strong>Esporta Eventi:</strong> Crea un PDF unico contenente tutte le pagine della scaletta di un evento.</li>
                    </ul>
                </div>

                <div class="form-group" style="text-align: left;">
                     <h4 style="margin-bottom: 12px;">Consigli:</h4>
                     <p>Per un'esperienza migliore, usa il pulsante "Installa App" (se disponibile) per aggiungere il Canzoniere alla schermata principale del tuo dispositivo.</p>
                </div>
                
                <div style="display: flex; justify-content: flex-end; margin-top: 24px;">
                    <button type="button" class="btn btn-primary" id="closeHelpBtn">Ho capito!</button>
                </div>
            </div>
        </div>

        <!-- Loading Overlay -->
        <div id="loading" class="loading" style="display: none;">
            <div class="spinner"></div>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.16.105/pdf.min.js"></script>
    <script src="./offline-assets/pdf.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
    <script src="./offline-assets/jspdf.umd.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
    <script src="./offline-assets/jszip.min.js"></script>
    <script>
        // Setup PDF.js worker
        pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.16.105/pdf.worker.min.js';

        // Utility function for debouncing
        function debounce(func, wait) {
            let timeout;
            return function(...args) {
                const context = this;
                clearTimeout(timeout);
                timeout = setTimeout(() => func.apply(context, args), wait);
            };
        }

        // Main App Class
        class CanzoniereApp {
            // --- CARTELLE ---
            createFolderPrompt() {
                const name = prompt('Nome nuova cartella:');
                if (!name || !name.trim()) return;
                const id = Date.now().toString();
                this.folders.push({ id, name: name.trim() });
                this.saveData().then(() => this.renderEventsList());
            }
            renameFolderPrompt(folderId) {
                const folder = this.folders.find(f => f.id === folderId);
                if (!folder) return;
                const name = prompt('Nuovo nome cartella:', folder.name);
                if (!name || !name.trim()) return;
                folder.name = name.trim();
                this.saveData().then(() => this.renderEventsList());
            }
            deleteFolderPrompt(folderId) {
                if (!confirm('Vuoi eliminare questa cartella? Gli eventi resteranno visibili fuori da ogni cartella.')) return;
                // Sposta eventi fuori dalla cartella
                this.events.forEach(ev => { if (ev.folderId === folderId) ev.folderId = null; });
                this.folders = this.folders.filter(f => f.id !== folderId);
                if (this.currentFolderId === folderId) this.currentFolderId = null;
                this.saveData().then(() => this.renderEventsList());
            }
            openFolder(folderId) {
                this.currentFolderId = folderId;
                this.renderEventsList();
            }
            // --- FINE CARTELLE ---
            // --- ESPORTAZIONE AVANZATA ---
            showExportModal() {
                // Crea la modale
                let modal = document.getElementById('exportModal');
                if (modal) modal.remove();
                modal = document.createElement('div');
                modal.id = 'exportModal';
                modal.className = 'modal-overlay';
                // PDF
                const pdfs = this.pdfs;
                // Cartelle
                const folders = this.folders;
                // Eventi fuori cartelle
                const eventsOut = this.events.filter(ev => !ev.folderId);
                // Eventi per cartella
                const eventsByFolder = {};
                for (const folder of folders) {
                    eventsByFolder[folder.id] = this.events.filter(ev => ev.folderId === folder.id);
                }
                // HTML
                let html = `<div class='modal-content' style='max-width:600px;'>
                    <h2><i class='fas fa-file-export'></i> Esporta dati</h2>
                    <form id='exportSelectForm'>
                        <h4>PDF</h4>
                        <div style='margin-bottom:12px;'>`;
                pdfs.forEach(pdf => {
                    html += `<label style='display:block; margin-bottom:4px;'><input type='checkbox' name='pdf' value='${pdf.id}' checked> <i class='fas fa-file-pdf'></i> ${pdf.name}</label>`;
                });
                html += `</div><h4>Cartelle</h4><div style='margin-bottom:12px;'>`;
                folders.forEach(folder => {
                    html += `<label style='display:block; margin-bottom:4px;'><input type='checkbox' name='folder' value='${folder.id}' checked> <i class='fas fa-folder'></i> ${folder.name}</label>`;
                });
                html += `</div><h4>Eventi fuori cartelle</h4><div style='margin-bottom:12px;'>`;
                eventsOut.forEach(ev => {
                    html += `<label style='display:block; margin-bottom:4px;'><input type='checkbox' name='event' value='${ev.id}' checked> <i class='fas fa-music'></i> ${ev.name}</label>`;
                });
                html += `</div><div style='display:flex; gap:12px; justify-content:flex-end; margin-top:24px;'>
                    <button type='button' class='btn btn-secondary' id='cancelExportBtn'>Annulla</button>
                    <button type='submit' class='btn btn-success'><i class='fas fa-file-export'></i> Esporta</button>
                </div></form></div>`;
                modal.innerHTML = html;
                document.body.appendChild(modal);
                // Eventi
                modal.querySelector('#cancelExportBtn').onclick = () => modal.remove();
                modal.querySelector('#exportSelectForm').onsubmit = (e) => {
                    e.preventDefault();
                    const form = e.target;
                    const pdfIds = Array.from(form.querySelectorAll('input[name="pdf"]:checked')).map(i => i.value);
                    const folderIds = Array.from(form.querySelectorAll('input[name="folder"]:checked')).map(i => i.value);
                    const eventIds = Array.from(form.querySelectorAll('input[name="event"]:checked')).map(i => i.value);
                    modal.remove();
                    this.exportAllData({ pdfIds, folderIds, eventIds });
                };
            }
            // --- FINE ESPORTAZIONE AVANZATA ---
            // --- DRAG & DROP EVENTI/CARTELLE ---
            handleEventDragStart(e, eventId) {
                e.dataTransfer.effectAllowed = 'move';
                e.dataTransfer.setData('text/plain', eventId);
                this._draggedEventId = eventId;
                setTimeout(() => {
                    e.target.classList.add('dragging');
                }, 0);
            }
            handleEventDragEnd(e) {
                this._draggedEventId = null;
                document.querySelectorAll('.drag-over').forEach(el => el.classList.remove('drag-over'));
                document.querySelectorAll('.dragging').forEach(el => el.classList.remove('dragging'));
            }
            handleDropOnFolder(e, folderId) {
                e.preventDefault();
                const eventId = e.dataTransfer.getData('text/plain');
                if (!eventId) return;
                const eventObj = this.events.find(ev => ev.id === eventId);
                if (!eventObj) return;
                eventObj.folderId = folderId || null;
                this.saveData().then(() => this.renderEventsList());
            }
            // --- FINE DRAG & DROP ---
            constructor() {
                this.pdfs = [];
                this.events = [];
                this.folders = [];
                this.currentFolderId = null;
                this.currentPdf = null;
                this.pdfDoc = null;
                this.currentPageNum = 1;
                this.isViewingEvent = false;
                this.currentEventId = null;
                this.currentEventPageIndex = 0;
                this.zoomLevel = 1; // Multiplier of fit-to-screen scale
                this.fitScale = 1; // The scale needed to fit the page to the screen
                this.pan = { x: 0, y: 0 }; // Track canvas translation
                this.currentRenderTask = null;
                this.editingEvent = null;
                this.pageInfoFromViewer = null;
                this._pageInfoToAttachOnSave = null;
                this.isReorderMode = false;
                this.selectedReorderPage = null;
                this.searchIndex = {}; // Initialize search index
                this.searchResultClickTimeout = null; // Flag per evitare doppi click/touch
                this.isRendering = false; // Flag per evitare race condition nel rendering
                this.pendingPageChange = null; // Pagina in attesa di rendering
                this.wakeLock = null;
                this.wakeLockSupported = 'wakeLock' in navigator;

                // Annotation system
                this.annotationState = {
                    isActive: false,
                    currentTool: null, // 'pen', 'eraser', 'note'
                    drawingCanvas: null,
                    drawingCtx: null,
                    isDrawing: false,
                    lastX: 0,
                    lastY: 0,
                    drawingHistory: [], // Array of drawing operations for undo
                    hasImportedDrawing: false, // Flag per tracciare se ci sono schizzi importati
                    hasImportedDrawingUnderSession: false, // Flag per tracciare se ci sono schizzi importati sotto quelli in sessione
                    currentPageAnnotations: {}, // Store annotations per page
                    stickyNotes: [], // Current page sticky notes
                    draggedNote: null,
                    dragOffset: { x: 0, y: 0 },
                    modifiedPages: new Set()
                };

                // Gesture handling
                this.gestureState = {
                    isSwipeActive: false,
                    startX: 0,
                    startY: 0,
                    lastZoom: 1,
                    zoomIndicatorTimeout: null
                };

                // UI elements
                this.pdfViewer = document.getElementById('pdfViewer');
                this.pdfCanvas = document.getElementById('pdfCanvas');
                this.drawingCanvas = document.getElementById('drawingCanvas');
                this.pdfContentWrapper = document.getElementById('pdfContentWrapper');
                this.stickyNotesContainer = document.getElementById('stickyNotesContainer');
                this.zoomIndicator = document.getElementById('zoomIndicator');
                this.recenterHint = document.getElementById('recenterHint');

                this.init();
            }

            async init() {
                this.assignUIElements();
                await this.loadData();
                await this.loadSearchIndex(); // Carica l'indice di ricerca già presente
                await this.loadAnnotationsFromStorage(); // Load saved annotations
                await this.cleanOrphanAnnotations(false); // Pulizia automatica senza toast
                this.setupEventListeners();
                this.setupPWA();
                this.renderUI();
                this.setupAdvancedGestures();
                // Indicizzazione automatica SOLO per PDF non ancora indicizzati
                await this.autoIndexExistingPdfs();
                // Pulsanti esporta/importa dati
                document.getElementById('exportDataBtn').addEventListener('click', () => this.showExportModal());
                document.getElementById('importDataBtn').addEventListener('click', () => document.getElementById('importDataInput').click());
                document.getElementById('importDataInput').addEventListener('change', (e) => this.importAllData(e));
                // Pulsante pulizia annotazioni
                const cleanBtn = document.getElementById('cleanAnnotationsBtn');
                if (cleanBtn) {
                    cleanBtn.addEventListener('click', () => this.cleanOrphanAnnotations(true));
                }
                // Initially show the PDF tab
                this.switchTab('pdfs');
            }

            assignUIElements() {
                this.canvas = document.getElementById('pdfCanvas');
                this.ctx = this.canvas.getContext('2d');
                this.pdfViewer = document.getElementById('pdfViewer');
                this.pdfControls = document.getElementById('pdfControls');
                this.pdfNavigation = document.getElementById('pdfNavigation');
                this.pageSlider = document.getElementById('pageSlider');
                this.addToEventBtn = document.getElementById('addToEventBtn');
                this.pdfSearchInput = document.getElementById('pdfSearch');
                this.pdfCanvasContainer = document.getElementById('pdfCanvasContainer');
                if (this.pdfCanvasContainer) {
                    const shouldIgnore = (event) => {
                        // Non chiudere se il tap/click parte dalla barra di ricerca o suoi figli
                        const searchInput = document.getElementById('pdfSearch');
                        const searchClear = document.getElementById('searchClear');
                        return searchInput && (searchInput === event.target || searchInput.contains(event.target))
                            || searchClear && (searchClear === event.target || searchClear.contains(event.target));
                    };
                    this.pdfCanvasContainer.addEventListener('mousedown', (e) => {
                        if (shouldIgnore(e)) return;
                        const searchResults = document.getElementById('searchResults');
                        if (searchResults && searchResults.classList.contains('show')) {
                            searchResults.classList.remove('show');
                            setTimeout(() => {
                                const searchInput = document.getElementById('pdfSearch');
                                if (searchInput) searchInput.focus();
                            }, 10);
                        }
                    });
                    this.pdfCanvasContainer.addEventListener('touchstart', (e) => {
                        if (shouldIgnore(e)) return;
                        const searchResults = document.getElementById('searchResults');
                        if (searchResults && searchResults.classList.contains('show')) {
                            searchResults.classList.remove('show');
                        }
                    });
                }
                this.pdfContentWrapper = document.getElementById('pdfContentWrapper'); // The new wrapper
                this.eventModal = document.getElementById('eventModal');
                this.eventDetailModal = document.getElementById('eventDetailModal');
                this.addPageModal = document.getElementById('addPageModal');
                this.uploadProgress = document.getElementById('uploadProgress');
                this.progressBar = document.getElementById('progressBar');
                this.swipeLeft = document.getElementById('swipeLeft');
                this.swipeRight = document.getElementById('swipeRight');
                this.zoomIndicator = document.getElementById('zoomIndicator');
                this.linkOverlaysContainer = document.getElementById('linkOverlays');
                this.helpModal = document.getElementById('helpModal');

                // Annotation elements
                this.annotationToggle = document.getElementById('annotationToggle');
                this.annotationTools = document.getElementById('annotationTools');
                this.penTool = document.getElementById('penTool');
                this.eraserTool = document.getElementById('eraserTool');
                this.noteTool = document.getElementById('noteTool');
                this.drawingCanvas = document.getElementById('drawingCanvas');
                this.stickyNotesContainer = document.getElementById('stickyNotesContainer');
                
                // Search elements
                this.searchResults = document.getElementById('searchResults');
                this.searchResultsList = document.getElementById('searchResultsList');
                this.searchLoading = document.getElementById('searchLoading');
                this.searchNoResults = document.getElementById('searchNoResults');
                this.searchNavigation = document.getElementById('searchNavigation');
                this.searchCount = document.getElementById('searchCount');
                this.searchPrevBtn = document.getElementById('searchPrevBtn');
                this.searchNextBtn = document.getElementById('searchNextBtn');
                this.searchClear = document.getElementById('searchClear');
                this.textHighlightsContainer = document.getElementById('textHighlightsContainer');
                
                // Initialize drawing canvas context
                if (this.drawingCanvas) {
                    this.annotationState.drawingCanvas = this.drawingCanvas;
                    this.annotationState.drawingCtx = this.drawingCanvas.getContext('2d');
                }

                // Debounced render function for smooth zoom (reduced wait time)
                this.debouncedRenderPage = debounce(() => {
                    this.renderCurrentPage();
                    this.updateViewerInfo();
                }, 50); // Reduced debounce time
            }

            setupPWA() {
                if ('serviceWorker' in navigator) {
                    window.addEventListener('load', () => {
                        registerServiceWorker();
                    });
                }

                let deferredPrompt;
                
                // Gestione prompt di installazione
                window.addEventListener('beforeinstallprompt', (e) => {
                    console.log('[PWA] Install prompt disponibile');
                    e.preventDefault();
                    deferredPrompt = e;
                    
                    // Mostra il prompt solo se l'app non è già installata
                    if (!this.isAppInstalled()) {
                        document.getElementById('installPrompt').classList.remove('hidden');
                    }
                });

                // Gestione click pulsante installazione
                document.getElementById('installBtn').addEventListener('click', async () => {
                    if (deferredPrompt) {
                        try {
                            deferredPrompt.prompt();
                            const { outcome } = await deferredPrompt.userChoice;
                            console.log(`[PWA] Risposta utente: ${outcome}`);
                            
                            if (outcome === 'accepted') {
                                this.showToast('App installata con successo!', 'success');
                            } else {
                                this.showToast('Installazione annullata', 'secondary');
                            }
                            
                            deferredPrompt = null;
                            document.getElementById('installPrompt').classList.add('hidden');
                        } catch (error) {
                            console.error('[PWA] Errore durante installazione:', error);
                            this.showToast('Errore durante l\'installazione', 'error');
                        }
                    } else {
                        // Fallback per browser che non supportano il prompt automatico
                        this.showInstallInstructions();
                    }
                });

                // Gestione app installata
                window.addEventListener('appinstalled', () => {
                    console.log('[PWA] App installata');
                    document.getElementById('installPrompt').classList.add('hidden');
                    this.showToast('App installata! Ora funziona offline.', 'success', 5000);
                });

                // Gestione aggiornamenti Service Worker
                navigator.serviceWorker?.addEventListener('message', event => {
                    if (event.data?.type === 'SW_ACTIVATED') {
                        console.log('[PWA] Service Worker attivato');
                        this.showToast('App pronta per l\'uso offline', 'success', 3000);
                    }
                });

                // Controlla se l'app è già installata
                if (this.isAppInstalled()) {
                    document.getElementById('installPrompt').classList.add('hidden');
                }
            }

            isAppInstalled() {
                // Controlla se l'app è in modalità standalone (installata)
                return window.matchMedia('(display-mode: standalone)').matches ||
                       window.navigator.standalone === true ||
                       document.referrer.includes('android-app://');
            }

            showInstallInstructions() {
                const isIOS = /iPad|iPhone|iPod/.test(navigator.userAgent);
                const isAndroid = /Android/.test(navigator.userAgent);
                
                let instructions = 'Per installare l\'app:';
                
                if (isIOS) {
                    instructions += '\n1. Tocca il pulsante Condividi (quadrato con freccia)\n2. Scorri e tocca "Aggiungi alla schermata Home"';
                } else if (isAndroid) {
                    instructions += '\n1. Tocca il menu del browser (⋮)\n2. Tocca "Aggiungi alla schermata Home" o "Installa app"';
                } else {
                    instructions += '\n1. Clicca sul menu del browser\n2. Cerca "Installa app" o "Aggiungi alla schermata Home"';
                }
                
                alert(instructions);
            }

            async loadData() {
                try {
                    const db = await this.openDB();
                    const transaction = db.transaction(['pdfs', 'events'], 'readonly');
                    const pdfsStore = transaction.objectStore('pdfs');
                    const eventsStore = transaction.objectStore('events');
                    this.pdfs = await this.getAllFromStore(pdfsStore);
                    this.events = await this.getAllFromStore(eventsStore);
                } catch (error) {
                    console.error('Error loading data:', error);
                    this.showToast('Errore nel caricamento dati. Prova a ricaricare la pagina.', 'error', 5000);
                }
            }

            openDB() {
                return new Promise((resolve, reject) => {
                    const request = indexedDB.open('CanzoniereDB', 4); // Increment version for search index
                    request.onerror = () => reject(request.error);
                    request.onsuccess = () => resolve(request.result);
                    request.onupgradeneeded = (event) => {
                        const db = event.target.result;
                        if (!db.objectStoreNames.contains('pdfs')) {
                            db.createObjectStore('pdfs', { keyPath: 'id' });
                        }
                        if (!db.objectStoreNames.contains('events')) {
                            db.createObjectStore('events', { keyPath: 'id' });
                        }
                        if (!db.objectStoreNames.contains('annotations')) {
                            db.createObjectStore('annotations', { keyPath: 'id' });
                        }
                        if (!db.objectStoreNames.contains('searchIndex')) {
                            db.createObjectStore('searchIndex', { keyPath: 'pdfId' });
                        }
                    };
                });
            }

            getAllFromStore(store) {
                return new Promise((resolve, reject) => {
                    const request = store.getAll();
                    request.onerror = () => reject(request.error);
                    request.onsuccess = () => resolve(request.result);
                });
            }

            setupEventListeners() {
                // Navigation tabs
                document.querySelectorAll('.nav-tab').forEach(tab => {
                    tab.addEventListener('click', (e) => {
                        this.switchTab(e.target.dataset.tab);
                    });
                });

                // Orientation change listener for mobile
                window.addEventListener('orientationchange', () => {
                    // Aggiorna la posizione dei risultati di ricerca dopo il cambio di orientamento
                    setTimeout(() => {
                        if (this.searchResults.classList.contains('show')) {
                            this.highlightCurrentSearchResult();
                        }
                    }, 500);
                });

                // PDF upload
                const uploadArea = document.getElementById('uploadArea');
                const pdfInput = document.getElementById('pdfInput');
                uploadArea.addEventListener('click', () => pdfInput.click());
                uploadArea.addEventListener('dragover', (e) => {
                    e.preventDefault();
                    uploadArea.classList.add('dragover');
                });
                uploadArea.addEventListener('dragleave', () => {
                    uploadArea.classList.remove('dragover');
                });
                uploadArea.addEventListener('drop', (e) => {
                    e.preventDefault();
                    uploadArea.classList.remove('dragover');
                    this.handleFileUpload(e.dataTransfer.files[0]);
                });
                pdfInput.addEventListener('change', (e) => {
                    if (e.target.files[0]) {
                        this.handleFileUpload(e.target.files[0]);
                    }
                });

                // PDF viewer controls
                document.getElementById('closePdfBtn').addEventListener('click', () => this.closePdfViewer());
                this.pageSlider.addEventListener('input', debounce((e) => {
                    this.goToPage(parseInt(e.target.value));
                }, 100)); // Debounce di 100ms
                this.addToEventBtn.addEventListener('click', () => this.showAddToEventModal());
                this.pdfSearchInput.addEventListener('input', debounce((e) => {
                    this.searchInPdf(e.target.value);
                    setTimeout(() => {
                        if (document.activeElement !== this.pdfSearchInput) {
                            this.pdfSearchInput.focus();
                        }
                    }, 10);
                }, 1000));

                // Search controls
                this.searchClear.addEventListener('click', () => {
                    this.clearSearch();
                    this.hideSearchResults && this.hideSearchResults();
                    const searchResults = document.getElementById('searchResults');
                    if (searchResults) searchResults.classList.remove('show');
                });
                this.searchPrevBtn.addEventListener('click', () => this.prevSearchResult());
                this.searchNextBtn.addEventListener('click', () => this.nextSearchResult());
                
                // Touch events for search results (mobile support) - RIMOSSI PER CONFLITTI
                // this.searchResults.addEventListener('touchstart', (e) => {
                //     const searchItem = e.target.closest('.search-result-item');
                //     if (searchItem) {
                //         e.stopPropagation();
                //         e.preventDefault();
                //         const index = parseInt(searchItem.dataset.index);
                //         this.goToSearchResult(index);
                //     }
                // }, { passive: false });

                // this.searchResults.addEventListener('click', (e) => {
                //     const searchItem = e.target.closest('.search-result-item');
                //     if (searchItem) {
                //         e.stopPropagation();
                //         const index = parseInt(searchItem.dataset.index);
                //         this.goToSearchResult(index);
                //     }
                // });
                
                // Show/hide search clear button based on input
                this.pdfSearchInput.addEventListener('input', (e) => {
                    this.searchClear.classList.toggle('show', e.target.value.length > 0);
                });

                // Page navigation arrows
                document.getElementById('swipeLeft').addEventListener('click', (e) => { e.stopPropagation(); this.prevPage(); });
                document.getElementById('swipeRight').addEventListener('click', (e) => { e.stopPropagation(); this.nextPage(); });
                // Supporto touch per le frecce su mobile
                document.getElementById('swipeLeft').addEventListener('touchstart', (e) => { e.preventDefault(); e.stopPropagation(); this.prevPage(); }, { passive: false });
                document.getElementById('swipeRight').addEventListener('touchstart', (e) => { e.preventDefault(); e.stopPropagation(); this.nextPage(); }, { passive: false });

                // Event management
                document.getElementById('createEventBtn').addEventListener('click', () => this.showEventModal());
                document.getElementById('eventForm').addEventListener('submit', (e) => this.saveEvent(e));
                document.getElementById('cancelEventBtn').addEventListener('click', () => this.hideEventModal());
                document.getElementById('deleteEventBtn').addEventListener('click', () => this.deleteEvent());
                document.getElementById('closeEventDetailBtn').addEventListener('click', () => this.hideEventDetailModal());
                document.getElementById('exportEventBtn').addEventListener('click', () => this.exportEventPdf());
                document.getElementById('viewEventBtn').addEventListener('click', () => this.startViewingEvent(this.eventDetailModal.dataset.eventId));
                document.getElementById('toggleReorderBtn').addEventListener('click', () => this.toggleReorderMode());
                document.getElementById('createEventFromAddPageBtn').addEventListener('click', async () => {
                    if (!this.pageInfoFromViewer) {
                        this.showToast("Errore: pagina non selezionata per il nuovo evento.", "error");
                        this.hideAddPageModal();
                        return;
                    }
                    const pageInfoToAttach = this.pageInfoFromViewer;
                    this.hideAddPageModal();
                    this.showEventModal(null, pageInfoToAttach);
                });
                document.getElementById('cancelAddPageBtn').addEventListener('click', () => this.hideAddPageModal());
                document.getElementById('refreshBtn').addEventListener('click', () => {
                    this.loadData().then(() => {
                        this.renderUI();
                        this.showToast('Dati aggiornati');
                    });
                });
                
                // Help modal listeners
                document.getElementById('helpBtn').addEventListener('click', () => this.showHelpModal());
                document.getElementById('closeHelpBtn').addEventListener('click', () => this.hideHelpModal());

                // Annotation controls
                this.annotationToggle.addEventListener('click', () => this.toggleAnnotationMode());
                this.penTool.addEventListener('click', () => this.selectAnnotationTool('pen'));
                this.eraserTool.addEventListener('click', () => this.selectAnnotationTool('eraser'));
                this.noteTool.addEventListener('click', () => this.selectAnnotationTool('note'));

                // Drawing canvas events
                this.drawingCanvas.addEventListener('mousedown', (e) => this.handleDrawingStart(e));
                this.drawingCanvas.addEventListener('mousemove', (e) => this.handleDrawingMove(e));
                this.drawingCanvas.addEventListener('mouseup', (e) => this.handleDrawingEnd(e));
                this.drawingCanvas.addEventListener('mouseleave', (e) => this.handleDrawingEnd(e));

                // Touch events for drawing
                this.drawingCanvas.addEventListener('touchstart', (e) => this.handleDrawingStart(e), { passive: false });
                this.drawingCanvas.addEventListener('touchmove', (e) => this.handleDrawingMove(e), { passive: false });
                this.drawingCanvas.addEventListener('touchend', (e) => this.handleDrawingEnd(e), { passive: false });

                // Modal click outside to close
                [this.eventModal, this.eventDetailModal, this.addPageModal, this.helpModal].forEach(modal => {
                    modal.addEventListener('click', (e) => {
                        if (e.target === modal) {
                            modal.style.display = 'none';
                            modal.classList.remove('show');
                        }
                    });
                });

                // Rimuovo l'event listener per il pulsante di re-indicizzazione (non più necessario)
                document.getElementById('reindexPdfsBtn').addEventListener('click', () => this.reindexAllPdfs());

                // Annotations list button
                document.getElementById('showAnnotationsListBtn').addEventListener('click', () => this.showAnnotationsList());

                document.getElementById('indexCurrentPdfBtn').addEventListener('click', () => this.indexCurrentPdf());
            }

            setupAdvancedGestures() {
                const container = this.pdfCanvasContainer;
                
                // Touch events for advanced gesture handling
                container.addEventListener('touchstart', (e) => this.handleTouchStart(e), { passive: false });
                container.addEventListener('touchmove', (e) => this.handleTouchMove(e), { passive: false });
                container.addEventListener('touchend', (e) => this.handleTouchEnd(e), { passive: false });
                
                // Tap a due dita per ricentrare
                container.addEventListener('touchend', (e) => this.handleTwoFingerTap(e), { passive: false });
                
                // Click to toggle controls
                container.addEventListener('click', (e) => {
                    // Se il click/tap è su una freccia swipe-indicator, sul tasto +, o sui risultati di ricerca, NON nascondere i controlli
                    if ((e.target.classList && e.target.classList.contains('swipe-indicator')) || 
                        e.target.id === 'addToEventBtn' || 
                        (e.target.closest && e.target.closest('#addToEventBtn')) ||
                        (e.target.closest && e.target.closest('.search-result-item')) ||
                        (e.target.closest && e.target.closest('#searchResults'))) {
                        // Questi elementi gestiscono già la loro azione, qui non si fa nulla
                        return;
                    }
                    // Se il click/tap è altrove (canvas o overlay), toggle dei controlli
                    if (e.target === this.canvas || e.target === this.linkOverlaysContainer) {
                        this.toggleControlsVisibility();
                    } else if (e.target.classList.contains('link-overlay')) {
                        // If clicked on a link overlay, handle it and prevent toggling controls
                        e.stopPropagation();
                        const url = e.target.dataset.url;
                        const pageNumber = e.target.dataset.pageNumber;
                        if (url) {
                            window.open(url, '_blank');
                        } else if (pageNumber) {
                            this.goToPage(parseInt(pageNumber, 10));
                        }
                    }
                });


                // Keyboard shortcuts
                document.addEventListener('keydown', (e) => {
                    if (this.pdfViewer.style.display === 'block') {
                        switch(e.key) {
                            case 'ArrowLeft':
                                e.preventDefault();
                                this.prevPage();
                                break;
                            case 'ArrowRight':
                                e.preventDefault();
                                this.nextPage();
                                break;
                            case 'Escape':
                                e.preventDefault();
                                this.closePdfViewer();
                                break;
                            case '+':
                            case '=':
                                e.preventDefault();
                                this.zoomIn();
                                break;
                            case '-':
                                e.preventDefault();
                                this.zoomOut();
                                break;
                            case 'f':
                                if (e.ctrlKey || e.metaKey) {
                                    e.preventDefault();
                                    this.pdfSearchInput.focus();
                                }
                                break;
                            case 'F3':
                                if (e.shiftKey) {
                                    e.preventDefault();
                                    this.prevSearchResult();
                                } else {
                                    e.preventDefault();
                                    this.nextSearchResult();
                                }
                                break;
                        }
                    }
                });
            }

            handleTouchStart(e) {
                // Se il touch è sui risultati di ricerca, NON gestire il gesture e ferma tutto
                if (e.target.closest && (e.target.closest('.search-result-item') || e.target.closest('#searchResults'))) {
                    e.stopPropagation();
                    e.preventDefault();
                    this.gestureState.isSwipeActive = false;
                    this.gestureState.isTap = false;
                    this.gestureState.isPinching = false;
                    return;
                }

                // Clear any existing link overlays before starting a gesture
                this.clearLinkOverlays();

                if (e.touches.length === 2) {
                    // Pinch gesture start
                    this.gestureState.isPinching = true;
                    this.gestureState.initialPinchDistance = this.getDistance(e.touches[0], e.touches[1]);
                    this.gestureState.lastZoom = this.zoomLevel;
                    this.gestureState.lastPan = this.pan;
                    this.gestureState.initialMidpoint = this.getMidpoint(e.touches[0], e.touches[1]);
                    this.pdfContentWrapper.style.transition = 'none';
                    e.preventDefault();
                } else if (e.touches.length === 1) {
                    // Single touch for swipe or tap
                    this.gestureState.isSwipeActive = true;
                    this.gestureState.startX = e.touches[0].clientX;
                    this.gestureState.startY = e.touches[0].clientY;
                    this.gestureState.currentX = e.touches[0].clientX;
                    this.gestureState.currentY = e.touches[0].clientY;
                    // Set a flag to detect if it was just a tap
                    this.gestureState.isTap = true;
                }
            }

            handleTouchMove(e) {
                // Se il touch è sui risultati di ricerca, NON gestire il gesture
                if (e.target.closest && (e.target.closest('.search-result-item') || e.target.closest('#searchResults'))) {
                    e.stopPropagation();
                    e.preventDefault();
                    return;
                }

                if (this.gestureState.isPinching && e.touches.length === 2) {
                    // --- 1. Calculate new zoom from pinch distance ---
                    const currentDistance = this.getDistance(e.touches[0], e.touches[1]);
                    const scaleFactor = currentDistance / this.gestureState.initialPinchDistance;
                    // Impedisco di scendere sotto il 100% (fit-to-screen)
                    this.zoomLevel = Math.max(1, Math.min(5, this.gestureState.lastZoom * scaleFactor));
                    this.showZoomIndicator();

                    // --- 2. Calculate new pan from midpoint movement ---
                    const currentMidpoint = this.getMidpoint(e.touches[0], e.touches[1]);
                    const panDelta = {
                        x: currentMidpoint.x - this.gestureState.initialMidpoint.x,
                        y: currentMidpoint.y - this.gestureState.initialMidpoint.y
                    };
                    this.pan = {
                        x: this.gestureState.lastPan.x + panDelta.x,
                        y: this.gestureState.lastPan.y + panDelta.y
                    };

                    // --- 3. Apply live transform for fluid preview ---
                    this.updateTransform();

                    this.gestureState.isTap = false;
                    e.preventDefault();
                } else if (this.gestureState.isSwipeActive && e.touches.length === 1) {
                    // This logic no longer handles swipes, it just detects if a touch
                    // becomes a drag, to differentiate it from a tap.
                    const deltaX = e.touches[0].clientX - this.gestureState.startX;
                    const deltaY = e.touches[0].clientY - this.gestureState.startY;
                    if (Math.sqrt(deltaX * deltaX + deltaY * deltaY) > 10) {
                        this.gestureState.isTap = false;
                    }
                }
            }

            handleTouchEnd(e) {
                // Se il touch è sui risultati di ricerca, NON gestire il gesture
                if (e.target.closest && (e.target.closest('.search-result-item') || e.target.closest('#searchResults'))) {
                    e.stopPropagation();
                    e.preventDefault();
                    this.gestureState.isSwipeActive = false;
                    this.gestureState.isTap = false;
                    this.gestureState.isPinching = false;
                    return;
                }

                this.hideZoomIndicator();

                // Effetto molla: solo se era attivo un pinch (gestureState.isPinching)
                if (this.gestureState.isPinching) {
                    this.gestureState.isPinching = false;
                    this.pdfContentWrapper.style.transition = 'transform 0.15s cubic-bezier(0.4, 0, 0.2, 1)';
                }
                // Se lo zoom è 100% e c'è stato un pan (con uno o più dita), ricentra la pagina
                if (Math.abs(this.zoomLevel - 1) < 0.01 && (this.pan.x !== 0 || this.pan.y !== 0)) {
                    // Qualsiasi touchend con un solo dito ricentra
                    if (e.changedTouches && e.changedTouches.length === 1) {
                        this.pan = { x: 0, y: 0 };
                        this.renderCurrentPage();
                    }
                }
                else if (this.gestureState.isSwipeActive) {
                    // We no longer check for swipes here. We only check for taps.
                    if (this.gestureState.isTap) {
                         this.toggleControlsVisibility();
                         e.preventDefault();
                    }
                    this.gestureState.isSwipeActive = false;
                }
                
                // Reset gesture state
                this.gestureState.startX = 0;
                this.gestureState.startY = 0;
                this.gestureState.currentX = 0;
                this.gestureState.currentY = 0;
                this.gestureState.isTap = false;
            }


            getDistance(touch1, touch2) {
                const dx = touch1.clientX - touch2.clientX;
                const dy = touch1.clientY - touch2.clientY;
                return Math.sqrt(dx * dx + dy * dy);
            }

            showSwipeIndicator(direction) {
                if (direction === 'left') {
                    this.swipeLeft.classList.add('show');
                    this.swipeRight.classList.remove('show');
                } else {
                    this.swipeRight.classList.add('show');
                    this.swipeLeft.classList.remove('show');
                }
            }

            hideSwipeIndicators() {
                this.swipeLeft.classList.remove('show');
                this.swipeRight.classList.remove('show');
            }

            showZoomIndicator() {
                this.zoomIndicator.textContent = `${Math.round(this.zoomLevel * 100)}%`;
                this.zoomIndicator.classList.add('show');
                
                // Clear previous timeout and set a new one for hiding
                clearTimeout(this.gestureState.zoomIndicatorTimeout);
                this.gestureState.zoomIndicatorTimeout = setTimeout(() => {
                    this.zoomIndicator.classList.remove('show');
                }, 500); // Hide after 500ms
            }

             hideZoomIndicator() {
                clearTimeout(this.gestureState.zoomIndicatorTimeout);
                this.zoomIndicator.classList.remove('show');
            }


            showControls() {
                this.pdfControls.classList.remove('hidden');
                this.pdfNavigation.classList.remove('hidden');
                // Mostra le frecce laterali solo quando le barre nere sono visibili
                document.getElementById('swipeLeft').style.display = '';
                document.getElementById('swipeRight').style.display = '';
                document.getElementById('addToEventBtn').style.display = '';
                // Adjust container padding to accommodate controls
                 this.pdfCanvasContainer.style.top = '80px';
                 this.pdfCanvasContainer.style.bottom = '90px';
            }

            hideControls() {
                this.pdfControls.classList.add('hidden');
                this.pdfNavigation.classList.add('hidden');
                // Nascondi le frecce laterali quando le barre nere sono nascoste
                document.getElementById('swipeLeft').style.display = 'none';
                document.getElementById('swipeRight').style.display = 'none';
                document.getElementById('addToEventBtn').style.display = '';
                // Expand container when controls are hidden
                 this.pdfCanvasContainer.style.top = '0';
                 this.pdfCanvasContainer.style.bottom = '0';
            }

            toggleControlsVisibility() {
                // Su dispositivi touch/mobile, i controlli restano sempre visibili
                if (this.pdfControls.classList.contains('hidden')) {
                    this.showControls();
                } else {
                    this.hideControls();
                }
            }

            // UI Management
            switchTab(tabName) {
                // Remove 'active' from all tab buttons and contents
                document.querySelectorAll('.nav-tab').forEach(tab => tab.classList.remove('active'));
                document.querySelectorAll('.tab-content').forEach(content => content.classList.remove('active'));

                // Add 'active' to the clicked tab button and its content
                document.querySelector(`[data-tab="${tabName}"]`).classList.add('active');
                document.getElementById(`${tabName}-tab`).classList.add('active');
            }


            renderUI() {
                this.renderPdfList();
                this.renderEventsList();
                 // Ensure the correct tab is shown based on initial load or refresh
                 const activeTab = document.querySelector('.nav-tab.active')?.dataset.tab || 'pdfs';
                 this.switchTab(activeTab);
            }

            renderPdfList() {
                const pdfList = document.getElementById('pdfList');
                if (this.pdfs.length === 0) {
                    pdfList.innerHTML = `
                        <div class="empty-state">
                            <i class="fas fa-file-pdf"></i>
                            <h3>Nessun PDF caricato</h3>
                            <p>Carica il tuo primo PDF per iniziare</p>
                        </div>
                    `;
                    return;
                }
                pdfList.innerHTML = this.pdfs.map(pdf => `
                    <div class="event-item" onclick="app.startViewing('${pdf.id}')">
                        <div class="event-info" style="flex: 1; min-width: 0;">
                            <div style="display: flex; align-items: center; justify-content: space-between; margin-bottom: 4px;">
                                <h3 style="margin: 0; flex: 1;"><i class="fas fa-file-pdf"></i> ${pdf.name}</h3>
                                <button class="btn btn-danger btn-sm btn-icon" onclick="event.stopPropagation(); app.deletePdf('${pdf.id}')" title="Elimina PDF" style="margin-left: 12px;">
                                    <i class="fas fa-trash"></i>
                                </button>
                            </div>
                            <p style="margin: 0 0 2px 0;">${pdf.pages} pagine • ${this.formatFileSize(pdf.size)}</p>
                            <small style="margin: 0;">Caricato il ${new Date(pdf.uploadDate).toLocaleDateString('it-IT')}</small>
                        </div>
                    </div>
                `).join('');
            }

            renderEventsList() {
                const eventsList = document.getElementById('eventsList');
                // UI: istruzione drag & drop
                let foldersHtml = `<div style='margin-bottom:8px; color:#2563eb; font-size:0.98em;'><i class='fas fa-info-circle'></i> Trascina gli eventi sulle cartelle per organizzarli. Trascina su "Fuori cartelle" per riportarli nell'elenco principale.</div>`;
                foldersHtml += `<div style="display: flex; align-items: center; gap: 10px; margin-bottom: 12px;">
                        <button class="btn btn-primary btn-sm" id="createFolderBtn"><i class="fas fa-folder-plus"></i> Nuova Cartella</button>
                        ${this.currentFolderId ? `<button class='btn btn-secondary btn-sm' id='backToRootBtn'><i class='fas fa-arrow-left'></i> Indietro</button>` : ''}
                    </div>
                `;
                // Lista cartelle
                if (!this.currentFolderId && this.folders.length > 0) {
                    foldersHtml += this.folders.map(folder => {
                        const count = this.events.filter(ev => ev.folderId === folder.id).length;
                        return `
                        <div class="event-item folder-drop-target" style="background: #f1f5f9; border-color: #64748b; cursor: pointer;" 
                            onclick="app.openFolder('${folder.id}')"
                            ondragover="event.preventDefault(); this.classList.add('drag-over')"
                            ondragleave="this.classList.remove('drag-over')"
                            ondrop="app.handleDropOnFolder(event, '${folder.id}')"
                        >
                            <div class="event-info">
                                <h3 style="color: #2563eb"><i class="fas fa-folder"></i> ${folder.name}</h3>
                                <small>${count} evento${count===1?'':'i'}</small>
                            </div>
                            <div class="event-actions">
                                <button class="btn btn-secondary btn-sm btn-icon" onclick="event.stopPropagation(); app.renameFolderPrompt('${folder.id}')" title="Rinomina cartella"><i class="fas fa-edit"></i></button>
                                <button class="btn btn-danger btn-sm btn-icon" onclick="event.stopPropagation(); app.deleteFolderPrompt('${folder.id}')" title="Elimina cartella"><i class="fas fa-trash"></i></button>
                            </div>
                        </div>
                        `;
                    }).join('');
                }
                // Eventi fuori da cartelle o dentro la cartella selezionata
                let eventsHtml = '';
                const eventsToShow = this.currentFolderId
                    ? this.events.filter(ev => ev.folderId === this.currentFolderId)
                    : this.events.filter(ev => !ev.folderId);
                if (eventsToShow.length === 0 && (!this.folders.length || this.currentFolderId)) {
                    eventsHtml = `
                        <div class="empty-state">
                            <i class="fas fa-calendar-alt"></i>
                            <h3>Nessun evento creato</h3>
                            <p>Crea il tuo primo evento per organizzare le scalette</p>
                        </div>
                    `;
                } else {
                    eventsHtml = eventsToShow.map(event => `
                        <div class="event-item" draggable="true" ondragstart="app.handleEventDragStart(event, '${event.id}')" ondragend="app.handleEventDragEnd(event)" onclick="app.showEventDetail('${event.id}')" style="border-color: ${event.color}">
                            <div class="event-info">
                                <h3 style="color: ${event.color}"><i class="fas fa-music"></i> ${event.name}</h3>
                                <p>${event.description || 'Nessuna descrizione'}</p>
                                <small>${event.pages.length} pagine nella scaletta • Creato il ${new Date(event.createdDate).toLocaleDateString('it-IT')}</small>
                            </div>
                            <div class="event-actions">
                                <button class="btn btn-secondary btn-sm btn-icon" onclick="event.stopPropagation(); app.editEvent('${event.id}')" title="Modifica evento">
                                    <i class="fas fa-edit"></i>
                                </button>
                                <button class="btn btn-danger btn-sm btn-icon" onclick="event.stopPropagation(); app.deleteEventConfirm('${event.id}')" title="Elimina evento">
                                    <i class="fas fa-trash"></i>
                                </button>
                            </div>
                        </div>
                    `).join('');
                }
                // Area drop per spostare eventi fuori dalle cartelle
                let dropAreaHtml = '';
                if (this.currentFolderId) {
                    dropAreaHtml = `<div class='event-item folder-drop-target' style='background:#e0edff; border:2px dashed #2563eb; color:#2563eb; justify-content:center; align-items:center; min-height:48px; margin-bottom:12px; text-align:center;' 
                        ondragover="event.preventDefault(); this.classList.add('drag-over')"
                        ondragleave="this.classList.remove('drag-over')"
                        ondrop="app.handleDropOnFolder(event, null)">
                        <i class="fas fa-level-up-alt"></i> Trascina qui per spostare l'evento fuori dalla cartella
                    </div>`;
                }
                eventsList.innerHTML = foldersHtml + dropAreaHtml + eventsHtml;
                // Event listeners per cartelle
                setTimeout(() => {
                    const btn = document.getElementById('createFolderBtn');
                    if (btn) btn.onclick = () => this.createFolderPrompt();
                    const backBtn = document.getElementById('backToRootBtn');
                    if (backBtn) backBtn.onclick = () => { this.currentFolderId = null; this.renderEventsList(); };
                }, 0);
            }

            // File Management
            async handleFileUpload(file) {
                if (!file || file.type !== 'application/pdf') {
                    this.showToast('Seleziona un file PDF valido', 'error');
                    return;
                }

                if (file.size > 50 * 1024 * 1024) {
                    this.showToast('Il file è troppo grande (max 50MB)', 'error');
                    return;
                }

                this.uploadProgress.classList.remove('hidden');
                this.progressBar.style.width = '0%';
                this.showToast('Caricamento in corso...', 'secondary');

                try {
                    const arrayBuffer = await this.readFileWithProgress(file);
                    const pdf = await pdfjsLib.getDocument({ data: arrayBuffer }).promise;

                    const pdfData = {
                        id: Date.now().toString(),
                        name: file.name,
                        size: file.size,
                        pages: pdf.numPages,
                        data: arrayBuffer,
                        uploadDate: new Date().toISOString()
                    };

                    this.pdfs.push(pdfData);
                    await this.saveData();
                    
                    // Indicizzazione automatica SOLO se non esiste già
                    const alreadyIndexed = this.searchIndex && this.searchIndex[pdfData.id];
                    if (!alreadyIndexed) {
                        this.showToast('Indicizzazione in corso...', 'secondary');
                        try {
                            await this.indexPdfText(pdfData.id);
                            this.showToast(`PDF "${pdfData.name}" caricato e indicizzato con successo!`, 'success');
                        } catch (indexError) {
                            console.error(`Errore nell'indicizzazione di ${pdfData.name}:`, indexError);
                            this.showToast(`PDF caricato ma errore nell'indicizzazione. La ricerca potrebbe non funzionare.`, 'warning');
                        }
                    } else {
                        this.showToast(`PDF "${pdfData.name}" caricato (indice già presente)`, 'success');
                    }
                    this.renderPdfList();
                } catch (error) {
                    console.error('Error uploading PDF:', error);
                    this.showToast('Errore nel caricamento del PDF', 'error');
                } finally {
                    this.uploadProgress.classList.add('hidden');
                    document.getElementById('pdfInput').value = '';
                }
            }

            readFileWithProgress(file) {
                return new Promise((resolve, reject) => {
                    const reader = new FileReader();
                    reader.onload = (e) => resolve(e.target.result);
                    reader.onerror = reject;
                    reader.onprogress = (e) => {
                        if (e.lengthComputable) {
                            const percent = Math.round((e.loaded / e.total) * 100);
                            this.progressBar.style.width = `${percent}%`;
                        }
                    };
                    reader.readAsArrayBuffer(file);
                });
            }

            async deletePdf(pdfId) {
                if (confirm('Sei sicuro di voler eliminare questo PDF? Verrà rimosso anche da tutte le scalette degli eventi.')) {
                    this.pdfs = this.pdfs.filter(pdf => pdf.id !== pdfId);
                    this.events.forEach(event => {
                        event.pages = event.pages.filter(page => page.pdfId !== pdfId);
                    });
                    // Pulizia annotazioni orfane (in memoria)
                    for (const key of Object.keys(this.annotationState.currentPageAnnotations)) {
                        if (key.startsWith(`pdf_${pdfId}_`)) {
                            delete this.annotationState.currentPageAnnotations[key];
                            this.annotationState.modifiedPages && this.annotationState.modifiedPages.delete(key);
                        }
                    }
                    // Pulizia annotazioni orfane (IndexedDB)
                    try {
                        const db = await this.openDB();
                        const transaction = db.transaction(['annotations'], 'readwrite');
                        const store = transaction.objectStore('annotations');
                        const req = store.getAllKeys();
                        const keys = await new Promise((resolve, reject) => {
                            req.onsuccess = () => resolve(req.result);
                            req.onerror = () => reject(req.error);
                        });
                        for (const key of keys) {
                            if (key.startsWith(`pdf_${pdfId}_`)) {
                                store.delete(key);
                            }
                        }
                    } catch (error) {
                        console.warn('Errore nella pulizia delle annotazioni orfane:', error);
                    }
                    // Rimuovi indice di ricerca SEMPRE
                    await this.removeSearchIndex(pdfId);
                    await this.saveData();
                    this.renderUI();
                    this.showToast('PDF eliminato');
                    if (this.currentPdf && this.currentPdf.id === pdfId) {
                        this.closePdfViewer();
                    }
                }
            }

            // PDF Viewer
            async startViewing(config) {
                this.pdfViewer.style.display = 'block';
                this.showLoading();
                this.showControls();
                
                // Attiva il Wake Lock per mantenere lo schermo acceso
                try {
                    await this.requestWakeLock();
                } catch (e) {
                    // Ignora errori wake lock
                }
                this.pdfSearchInput.value = '';
                this.pdfCanvasContainer.scrollTop = 0;
                this.pdfCanvasContainer.scrollLeft = 0;
                this.clearLinkOverlays(); // Clear any existing overlays

                // Aggiorna l'elenco delle pagine modificate ogni volta che si apre un PDF
                this.updateModifiedPagesFromStorage();

                try {
                    if (typeof config === 'string') {
                        this.isViewingEvent = false;
                        this.currentEventId = null;
                        this.currentEventPageIndex = 0;
                        const pdf = this.pdfs.find(p => p.id === config);
                        if (!pdf) {
                            console.error('PDF not found with id:', config);
                            throw new Error('PDF non trovato');
                        }
                        
                        // Verifica che i dati del PDF siano validi
                        if (!pdf.data || !(pdf.data instanceof ArrayBuffer)) {
                            console.error('PDF data is invalid:', pdf);
                            throw new Error('Dati PDF non validi');
                        }
                        
                        this.currentPdf = pdf;
                        this.currentPageNum = 1;
                        this.zoomLevel = 1;
                        this.pan = { x: 0, y: 0 }; // Reset pan
                        
                        console.log('Loading PDF document...');
                        console.log('[DEBUG] PDF data size:', pdf.data.byteLength);
                        this.pdfDoc = await pdfjsLib.getDocument({ data: pdf.data }).promise;
                        console.log('PDF document loaded successfully');
                        console.log('[DEBUG] PDF document numPages:', this.pdfDoc.numPages);
                        console.log('[DEBUG] PDF document fingerprint:', this.pdfDoc.fingerprint);
                        
                        this.pageSlider.max = this.pdfDoc.numPages;
                        this.pageSlider.value = this.currentPageNum;
                        this.addToEventBtn.style.display = 'flex';
                        await this.renderCurrentPage();
                        this.updateViewerInfo();
                        
                        // Load annotations for this page
                        if (this.annotationState.isActive) {
                            this.loadPageAnnotations();
                        }
                    } else if (typeof config === 'object' && config.type === 'event') {
                        this.isViewingEvent = true;
                        this.currentEventId = config.eventId;
                        this.currentEventPageIndex = config.pageIndex || 0;

                        // --- START FIX: Explicitly reset visual and logical state ---
                        this.canvas.style.transform = ''; // Reset visual state first
                        this.zoomLevel = 1;
                        this.pan = { x: 0, y: 0 };
                        // --- END FIX ---

                        const event = this.events.find(e => e.id === this.currentEventId);
                        if (!event || event.pages.length === 0) {
                            this.showToast('L\'evento non contiene pagine.', 'error');
                            this.closePdfViewer();
                            return;
                        }
                        if (this.currentEventPageIndex >= event.pages.length) {
                            this.currentEventPageIndex = event.pages.length - 1;
                        }
                        if (this.currentEventPageIndex < 0) {
                            this.currentEventPageIndex = 0;
                        }
                        const pageInfo = event.pages[this.currentEventPageIndex];
                        const pdf = this.pdfs.find(p => p.id === pageInfo.pdfId);
                        if (!pdf) {
                            this.showToast('PDF originale non trovato per questa pagina.', 'error');
                            // Attempt to load the next page if available in event
                            if (event.pages.length > 1) {
                                // Remove missing page from event
                                event.pages.splice(this.currentEventPageIndex, 1);
                                await this.saveData();
                                this.showToast('Pagina con PDF mancante rimossa dalla scaletta.', 'warning');
                                // Try to load the next page (or previous if at the end)
                                const nextPageIndex = Math.min(this.currentEventPageIndex, event.pages.length - 1);
                                if (nextPageIndex >= 0) {
                                    this.startViewing({ type: 'event', eventId: this.currentEventId, pageIndex: nextPageIndex });
                                } else {
                                    this.closePdfViewer();
                                }
                            } else {
                                this.closePdfViewer();
                            }
                                this.renderEventsList(); // Update event list after removing page
                            return;
                        }
                        
                        // --- START FIX: Optimized PDF loading ---
                        const isDifferentPdf = !this.pdfDoc || !this.currentPdf || this.currentPdf.id !== pdf.id;
                        this.currentPdf = pdf; // Set current PDF before loading
                        if (isDifferentPdf) {
                            console.log('[DEBUG] Caricamento PDF diverso per evento');
                            console.log('[DEBUG] PDF data size:', pdf.data.byteLength);
                            if (this.pdfDoc) this.pdfDoc.destroy();
                            this.pdfDoc = await pdfjsLib.getDocument({ data: pdf.data }).promise;
                            console.log('[DEBUG] PDF document caricato per evento, numPages:', this.pdfDoc.numPages);
                        } else {
                            console.log('[DEBUG] PDF già caricato, riutilizzo');
                        }
                        // --- END FIX ---
                        
                        this.currentPageNum = pageInfo.pageNumber;
                        this.pageSlider.max = event.pages.length;
                        this.pageSlider.value = this.currentEventPageIndex + 1;
                        this.addToEventBtn.style.display = 'none';
                        await this.renderCurrentPage();
                        this.updateViewerInfo();
                    } else {
                        throw new Error('Invalid viewer configuration');
                    }
                } catch (error) {
                    console.error('Error starting viewer:', error);
                    console.error('Error details:', {
                        message: error.message,
                        stack: error.stack,
                        config: config
                    });
                    this.showToast(`Errore nell'apertura del PDF/Evento: ${error.message}`, 'error');
                    this.closePdfViewer();
                } finally {
                    this.hideLoading();
                }
            }

                       async renderCurrentPage() {
                if (!this.pdfDoc || !this.canvas || !this.ctx) return;

                // Cancella il task di rendering precedente se esiste
                if (this.currentRenderTask) {
                    this.currentRenderTask.cancel();
                    this.currentRenderTask = null;
                }

                // Pulisci il canvas prima di iniziare il nuovo rendering
                this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);

                this.clearLinkOverlays();
                this.clearTextHighlights(); // Clear search highlights when changing page

                try {
                    const page = await this.pdfDoc.getPage(this.currentPageNum);
                    const containerWidth = this.pdfCanvasContainer.clientWidth;
                    const containerHeight = this.pdfCanvasContainer.clientHeight;
                    
                    // Always calculate the base fit-to-screen scale
                    const viewportUnscaled = page.getViewport({ scale: 1 });
                    this.fitScale = Math.min(containerWidth / viewportUnscaled.width, containerHeight / viewportUnscaled.height);
                    
                    // Render at a resolution based on the current zoom level, ensuring quality
                    const renderScale = this.fitScale * this.zoomLevel;
                    const viewport = page.getViewport({ scale: renderScale });
                    
                    // --- START HiDPI/Retina Rendering FIX ---
                    const devicePixelRatio = window.devicePixelRatio || 1;
                    this.canvas.width = Math.floor(viewport.width * devicePixelRatio);
                    this.canvas.height = Math.floor(viewport.height * devicePixelRatio);
                    this.canvas.style.width = `${Math.floor(viewport.width)}px`;
                    this.canvas.style.height = `${Math.floor(viewport.height)}px`;
                    
                    this.linkOverlaysContainer.style.width = `${Math.floor(viewport.width)}px`;
                    this.linkOverlaysContainer.style.height = `${Math.floor(viewport.height)}px`;

                    // Sync drawing canvas dimensions
                    this.drawingCanvas.width = Math.floor(viewport.width * devicePixelRatio);
                    this.drawingCanvas.height = Math.floor(viewport.height * devicePixelRatio);
                    this.drawingCanvas.style.width = `${Math.floor(viewport.width)}px`;
                    this.drawingCanvas.style.height = `${Math.floor(viewport.height)}px`;
                    
                    this.stickyNotesContainer.style.width = `${Math.floor(viewport.width)}px`;
                    this.stickyNotesContainer.style.height = `${Math.floor(viewport.height)}px`;

                    const renderContext = {
                        canvasContext: this.ctx,
                        viewport: viewport,
                        transform: [devicePixelRatio, 0, 0, devicePixelRatio, 0, 0],
                    };
                    // --- END HiDPI/Retina Rendering FIX ---
                    
                    this.currentRenderTask = page.render(renderContext);
                    
                    await this.currentRenderTask.promise;

                    // Verifica che il task non sia stato cancellato durante il rendering
                    if (this.currentRenderTask === null) {
                        return; // Il rendering è stato cancellato
                    }

                    // Hyperlinks need to be scaled to the new render resolution.
                    this.addLinkOverlays(page, viewport);

                    // Sticky note e disegno sono sempre visibili e modificabili
                    this.loadStickyNotesForCurrentPage();
                    this.loadDrawingForCurrentPage();
                    this.drawingCanvas.classList.add('active');
                    this.stickyNotesContainer.style.pointerEvents = 'auto';

                    // Applica le trasformazioni di zoom e pan
                    this.updateTransform();

                } catch (error) {
                    if (error.name !== 'RenderingCancelledException') {
                        console.error('Error rendering page:', error);
                        this.showToast('Errore nel rendering della pagina', 'error');
                    }
                } finally {
                    this.currentRenderTask = null;
                }
            }

             async addLinkOverlays(page, viewport) {
                this.clearLinkOverlays();
                const annotations = await page.getAnnotations();

                for (const annotation of annotations) {
                    if (annotation.subtype !== 'Link') {
                        continue;
                    }

                    const linkRect = annotation.rect;
                    const [x1, y1, x2, y2] = viewport.convertToViewportRectangle(linkRect);

                    const overlay = document.createElement('div');
                    overlay.classList.add('link-overlay');
                    overlay.style.left = `${x1}px`;
                    overlay.style.top = `${y1}px`;
                    overlay.style.width = `${x2 - x1}px`;
                    overlay.style.height = `${y2 - y1}px`;

                    if (annotation.url) {
                        overlay.dataset.url = annotation.url;
                        overlay.style.cursor = 'pointer';
                        overlay.style.pointerEvents = 'auto';
                        overlay.style.border = '';
                        overlay.addEventListener('click', (e) => {
                            e.stopPropagation();
                            window.open(annotation.url, '_blank');
                        });
                        // Rimuovi qualsiasi pointer-events: none dal canvas
                        const pdfCanvas = document.getElementById('pdfCanvas');
                        if (pdfCanvas) pdfCanvas.style.pointerEvents = '';
                        this.linkOverlaysContainer.appendChild(overlay);
                    } else if (annotation.dest) {
                        try {
                            let pageIndex;
                            if (typeof annotation.dest === 'string') {
                                const namedDest = await this.pdfDoc.getDestination(annotation.dest);
                                if (namedDest) {
                                    pageIndex = await this.pdfDoc.getPageIndex(namedDest[0]);
                                }
                            } else if (Array.isArray(annotation.dest)) {
                                pageIndex = await this.pdfDoc.getPageIndex(annotation.dest[0]);
                            }

                            if (pageIndex !== undefined) {
                                const pageNumber = pageIndex + 1;
                                overlay.dataset.pageNumber = pageNumber;
                                this.linkOverlaysContainer.appendChild(overlay);
                            }
                        } catch (error) {
                            console.error('Error resolving internal link destination:', error);
                        }
                    }
                }
             }

             clearLinkOverlays() {
                while (this.linkOverlaysContainer.firstChild) {
                    this.linkOverlaysContainer.removeChild(this.linkOverlaysContainer.firstChild);
                }
             }


            closePdfViewer() {
                // Salva annotazioni e mostra notifica
                this.savePageAnnotations();
                this.showToast('Annotazioni salvate', 'secondary', 1500);
                
                // Ferma il salvataggio automatico
                this.stopAutoSaveAnnotations();
                
                // Rilascia il Wake Lock
                this.releaseWakeLock();
                
                this.pdfViewer.style.display = 'none';
                if (this.pdfDoc) {
                    this.pdfDoc.destroy();
                    this.pdfDoc = null;
                }
                this.currentPdf = null;
                this.isViewingEvent = false;
                this.currentEventId = null;
                this.currentEventPageIndex = 0;
                this.currentPageNum = 1;
                this.zoomLevel = 1;
                this.pan = { x: 0, y: 0 }; // Reset pan
                this.pageSlider.value = 1;
                this.pageSlider.max = 1;
                this.updateViewerInfo();
                this.showControls();
                this.pdfCanvasContainer.scrollTop = 0;
                this.pdfCanvasContainer.scrollLeft = 0;
                this.currentRenderTask = null;
                this.hideSwipeIndicators();
                this.hideZoomIndicator();
                this.clearLinkOverlays(); // Clear overlays on close
                
                // Clear search
                this.clearSearch();
                
                // Clear annotations state
                this.annotationState.isActive = false;
                this.annotationState.currentTool = null;
                this.annotationToggle.classList.remove('active');
                this.annotationTools.classList.remove('show');
                this.drawingCanvas.classList.remove('active');
                this.stickyNotesContainer.style.pointerEvents = 'none';
                this.clearAnnotations();
            }

            async nextPage() {
                console.log('🔵 nextPage() chiamata');
                // Salva annotazioni prima di cambiare pagina
                this.savePageAnnotations();
                if (this.isViewingEvent) {
                    const event = this.events.find(e => e.id === this.currentEventId);
                    if (!event || event.pages.length === 0 || this.currentEventPageIndex >= event.pages.length - 1) return;
                    
                    // Verifica se la prossima pagina è dello stesso PDF
                    const currentPageInfo = event.pages[this.currentEventPageIndex];
                    const nextPageInfo = event.pages[this.currentEventPageIndex + 1];
                    
                    console.log('🔵 nextPage - currentPageInfo:', currentPageInfo);
                    console.log('🔵 nextPage - nextPageInfo:', nextPageInfo);
                    console.log('🔵 nextPage - pdfDoc exists:', !!this.pdfDoc);
                    
                    if (currentPageInfo.pdfId === nextPageInfo.pdfId && this.pdfDoc) {
                        // Stesso PDF, naviga direttamente senza ricaricare
                        console.log('🔵 nextPage - stesso PDF, navigazione diretta');
                        this.currentEventPageIndex++;
                        this.currentPageNum = nextPageInfo.pageNumber;
                        this.pageSlider.value = this.currentEventPageIndex + 1;
                        await this.renderCurrentPage();
                        this.updateViewerInfo();
                    } else {
                        // PDF diverso, usa startViewing per ricaricare
                        console.log('🔵 nextPage - PDF diverso, usa startViewing');
                        await this.startViewing({ type: 'event', eventId: this.currentEventId, pageIndex: this.currentEventPageIndex + 1 });
                    }
                } else {
                    if (!this.pdfDoc || this.currentPageNum >= this.pdfDoc.numPages) return;
                    this.currentPageNum++;
                    this.clearLinkOverlays();
                    this.clearTextHighlights(); // Clear search highlights
                    await this.renderCurrentPage();
                    this.updateViewerInfo();
                    this.pageSlider.value = this.currentPageNum;
                }
            }

            async prevPage() {
                console.log('🔴 prevPage() chiamata');
                // Salva annotazioni prima di cambiare pagina
                this.savePageAnnotations();
                if (this.isViewingEvent) {
                    const event = this.events.find(e => e.id === this.currentEventId);
                    if (!event || event.pages.length === 0 || this.currentEventPageIndex <= 0) return;
                    
                    // Verifica se la pagina precedente è dello stesso PDF
                    const currentPageInfo = event.pages[this.currentEventPageIndex];
                    const prevPageInfo = event.pages[this.currentEventPageIndex - 1];
                    
                    console.log('🔴 prevPage - currentPageInfo:', currentPageInfo);
                    console.log('🔴 prevPage - prevPageInfo:', prevPageInfo);
                    console.log('🔴 prevPage - pdfDoc exists:', !!this.pdfDoc);
                    
                    if (currentPageInfo.pdfId === prevPageInfo.pdfId && this.pdfDoc) {
                        // Stesso PDF, naviga direttamente senza ricaricare
                        console.log('🔴 prevPage - stesso PDF, navigazione diretta');
                        this.currentEventPageIndex--;
                        this.currentPageNum = prevPageInfo.pageNumber;
                        this.pageSlider.value = this.currentEventPageIndex + 1;
                        await this.renderCurrentPage();
                        this.updateViewerInfo();
                    } else {
                        // PDF diverso, usa startViewing per ricaricare
                        console.log('🔴 prevPage - PDF diverso, usa startViewing');
                        await this.startViewing({ type: 'event', eventId: this.currentEventId, pageIndex: this.currentEventPageIndex - 1 });
                    }
                } else {
                    if (!this.pdfDoc || this.currentPageNum <= 1) return;
                    this.currentPageNum--;
                    this.clearLinkOverlays();
                    this.clearTextHighlights(); // Clear search highlights
                    await this.renderCurrentPage();
                    this.updateViewerInfo();
                    this.pageSlider.value = this.currentPageNum;
                }
            }

            async goToPage(value) {
                console.log('🎯 goToPage() chiamata con valore:', value);
                // Salva annotazioni prima di cambiare pagina
                if (this.annotationState.isActive) this.savePageAnnotations();
                value = parseInt(value);
                if (isNaN(value)) return;
                
                // Se è già in corso un rendering, salva questa pagina come pending
                if (this.isRendering) {
                    this.pendingPageChange = value;
                    return;
                }
                
                this.isRendering = true;
                
                try {
                    if (this.isViewingEvent) {
                        const eventPageIndex = value - 1;
                        const event = this.events.find(e => e.id === this.currentEventId);
                        if (!event || event.pages.length === 0 || eventPageIndex < 0 || eventPageIndex >= event.pages.length) return;
                        
                        // Verifica se la pagina di destinazione è dello stesso PDF
                        const currentPageInfo = event.pages[this.currentEventPageIndex];
                        const targetPageInfo = event.pages[eventPageIndex];
                        
                        console.log('🎯 goToPage - currentPageInfo:', currentPageInfo);
                        console.log('🎯 goToPage - targetPageInfo:', targetPageInfo);
                        console.log('🎯 goToPage - pdfDoc exists:', !!this.pdfDoc);
                        
                        if (currentPageInfo.pdfId === targetPageInfo.pdfId && this.pdfDoc) {
                            // Stesso PDF, naviga direttamente senza ricaricare
                            console.log('🎯 goToPage - stesso PDF, navigazione diretta');
                            this.currentEventPageIndex = eventPageIndex;
                            this.currentPageNum = targetPageInfo.pageNumber;
                            this.pageSlider.value = this.currentEventPageIndex + 1;
                            await this.renderCurrentPage();
                            this.updateViewerInfo();
                        } else {
                            // PDF diverso, usa startViewing per ricaricare
                            console.log('🎯 goToPage - PDF diverso, usa startViewing');
                            await this.startViewing({ type: 'event', eventId: this.currentEventId, pageIndex: eventPageIndex });
                        }
                    } else {
                        if (!this.pdfDoc) return;
                        const pageNum = value;
                        if (pageNum >= 1 && pageNum <= this.pdfDoc.numPages) {
                            this.currentPageNum = pageNum;
                            this.clearTextHighlights(); // Clear search highlights
                            await this.renderCurrentPage();
                            this.updateViewerInfo();
                        }
                    }
                } finally {
                    this.isRendering = false;
                    
                    // Se c'è una pagina in attesa, processala
                    if (this.pendingPageChange !== null) {
                        const pendingPage = this.pendingPageChange;
                        this.pendingPageChange = null;
                        // Usa setTimeout per evitare chiamate ricorsive immediate
                        setTimeout(() => this.goToPage(pendingPage), 10);
                    }
                }
            }

            async goToEventPage(eventPageIndex) {
                const event = this.events.find(e => e.id === this.currentEventId);
                if (!event || event.pages.length === 0 || eventPageIndex < 0 || eventPageIndex >= event.pages.length) {
                    this.closePdfViewer();
                    return;
                }
                this.showLoading();
                 this.clearLinkOverlays(); // Clear overlays when changing event page
                try {
                    const pageInfo = event.pages[eventPageIndex];
                    const pdf = this.pdfs.find(p => p.id === pageInfo.pdfId);
                    if (!pdf) {
                        this.showToast('PDF originale non trovato per questa pagina.', 'error');
                        // Attempt to load the next page if available in event
                        if (event.pages.length > 1) {
                             // Remove missing page from event
                             event.pages.splice(eventPageIndex, 1);
                             await this.saveData();
                             this.showToast('Pagina con PDF mancante rimossa dalla scaletta.', 'warning');
                              // Try to load the next page (or previous if at the end)
                             const nextPageIndex = Math.min(eventPageIndex, event.pages.length - 1);
                             if (nextPageIndex >= 0) {
                                this.startViewing({ type: 'event', eventId: this.currentEventId, pageIndex: nextPageIndex });
                            } else {
                                 this.closePdfViewer();
                            }
                        } else {
                            this.closePdfViewer();
                        }
                         this.renderEventsList(); // Update event list after removing page
                        return;
                    }
                    
                    // DEPRECATED: This function is no longer called by navigation controls to prevent state issues.
                    // It is kept for its logic for handling missing PDFs, which is called by startViewing.
                    // The main startViewing function now handles the core navigation logic.
                    if (!this.pdfDoc || this.currentPdf.id !== pdf.id) {
                         if (this.pdfDoc) this.pdfDoc.destroy(); // Destroy previous doc to free memory
                         this.pdfDoc = await pdfjsLib.getDocument({ data: pdf.data }).promise;
                    }
                    
                    this.currentPdf = pdf;
                    this.currentPageNum = pageInfo.pageNumber;
                    this.zoomLevel = 1;
                    
                    await this.renderCurrentPage();
                    this.currentEventPageIndex = eventPageIndex;
                    this.updateViewerInfo();
                    this.pageSlider.value = this.currentEventPageIndex + 1;
                    this.pdfCanvasContainer.scrollTop = 0;
                    this.pdfCanvasContainer.scrollLeft = 0;
                } catch (error) {
                    console.error('Error navigating event page:', error);
                    this.showToast('Errore nel caricamento pagina evento', 'error');
                    this.closePdfViewer();
                } finally {
                    this.hideLoading();
                }
            }


            async zoomIn() {
                if (this.annotationState.isActive) this.savePageAnnotations();
                this.zoomLevel *= 1.25;
                await this.renderCurrentPage();
                this.updateViewerInfo();
            }

            async zoomOut() {
                if (this.annotationState.isActive) this.savePageAnnotations();
                const previousZoom = this.zoomLevel;
                this.zoomLevel /= 1.25;
                
                // Se lo zoom è troppo basso, resetta e adatta a schermo
                if (this.fitScale * this.zoomLevel < 0.4) {
                    this.fitToScreen();
                    return;
                }
                
                // Auto-centra quando si torna al 100% (o molto vicino)
                if (Math.abs(this.zoomLevel - 1) < 0.1) {
                    this.zoomLevel = 1;
                    this.pan = { x: 0, y: 0 };
                    // this.showToast('Pagina centrata automaticamente', 'info', 2000);
                } else if (previousZoom > 1 && this.zoomLevel <= 1 && (this.pan.x !== 0 || this.pan.y !== 0)) {
                    // Mostra istruzione solo quando si passa da zoom > 100% a 100% e la pagina non è centrata
                    this.showRecenterHint();
                }
                
                await this.renderCurrentPage();
                this.updateViewerInfo();
            }

            fitToScreen() {
                if (this.annotationState.isActive) this.savePageAnnotations();
                this.zoomLevel = 1;
                this.pan = { x: 0, y: 0 };
                this.renderCurrentPage();
                this.updateViewerInfo();
            }

            updateViewerInfo() {
                const pageInfoDisplay = document.getElementById('pageInfoDisplay');
                if (this.isViewingEvent) {
                    const event = this.events.find(e => e.id === this.currentEventId);
                    if (event && event.pages.length > 0) {
                        pageInfoDisplay.textContent = `Scaletta ${this.currentEventPageIndex + 1} / ${event.pages.length}`;
                    } else {
                        pageInfoDisplay.textContent = `Scaletta Vuota`;
                    }
                } else {
                    if (this.pdfDoc) {
                        pageInfoDisplay.textContent = `${this.currentPageNum} / ${this.pdfDoc.numPages}`;
                    } else {
                        pageInfoDisplay.textContent = `Nessun PDF`;
                    }
                }
            }

            // Event Management
            showEventModal(eventId = null, pageInfoToAttach = null) {
                this.editingEvent = eventId;
                this._pageInfoToAttachOnSave = pageInfoToAttach;
                const title = document.getElementById('eventModalTitle');
                if (eventId) {
                    const event = this.events.find(e => e.id === eventId);
                    if (!event) return;
                    title.textContent = 'Modifica Evento';
                    document.getElementById('eventName').value = event.name;
                    document.getElementById('eventDescription').value = event.description || '';
                    document.getElementById('eventColor').value = event.color;
                } else {
                    title.textContent = 'Nuovo Evento';
                    document.getElementById('eventForm').reset();
                    document.getElementById('eventColor').value = '#3B82F6';
                }
                this.eventModal.style.display = 'flex';
                this.eventModal.classList.add('show');
                setTimeout(() => document.getElementById('eventName').focus(), 100);
            }

            hideEventModal() {
                this.eventModal.classList.remove('show');
                setTimeout(() => {
                    this.eventModal.style.display = 'none';
                    this.editingEvent = null;
                    this._pageInfoToAttachOnSave = null;
                    this.pageInfoFromViewer = null;
                }, 300);
            }

            async saveEvent(e) {
                e.preventDefault();
                const name = document.getElementById('eventName').value.trim();
                const description = document.getElementById('eventDescription').value.trim();
                const color = document.getElementById('eventColor').value;
                if (!name) {
                    this.showToast('Il nome dell\'evento è obbligatorio', 'error');
                    return;
                }
                let event;
                let isNewEvent = false;
                if (this.editingEvent) {
                    event = this.events.find(e => e.id === this.editingEvent);
                    if (event) {
                        event.name = name;
                        event.description = description;
                        event.color = color;
                        this.showToast('Evento modificato!');
                    }
                } else {
                    isNewEvent = true;
                    event = {
                        id: Date.now().toString(),
                        name,
                        description,
                        color,
                        pages: [],
                        createdDate: new Date().toISOString()
                    };
                    if (this._pageInfoToAttachOnSave) {
                        event.pages.push(this._pageInfoToAttachOnSave);
                    }
                    this.events.push(event);
                }
                try {
                    await this.saveData();
                    this.renderEventsList();
                    this.hideEventModal();
                    if (isNewEvent) {
                        if (this._pageInfoToAttachOnSave) {
                            this.showToast(`Evento "${event.name}" creato e pagina aggiunta!`);
                            setTimeout(() => {
                                this.showEventDetail(event.id);
                            }, 100);
                        } else {
                            this.showToast(`Nuovo evento "${event.name}" creato!`);
                        }
                    }
                } catch (error) {
                    console.error("Error during saveEvent process:", error);
                }
            }

            editEvent(eventId) {
                const event = this.events.find(e => e.id === eventId);
                if(event) {
                    this.showEventModal(eventId);
                }
            }

            deleteEventConfirm(eventId) {
                if (confirm('Sei sicuro di voler eliminare questo evento?')) {
                    this.deleteEvent(eventId);
                }
            }

            async deleteEvent(eventId) {
                const idToDelete = eventId || this.eventDetailModal.dataset.eventId;
                if (!idToDelete) return;
                this.events = this.events.filter(e => e.id !== idToDelete);
                await this.saveData();
                this.renderEventsList();
                if (this.eventDetailModal.style.display !== 'none' && this.eventDetailModal.dataset.eventId === idToDelete) {
                    this.hideEventDetailModal();
                }
                if (this.isViewingEvent && this.currentEventId === idToDelete) {
                    this.closePdfViewer();
                }
                this.showToast('Evento eliminato');
            }

            showEventDetail(eventId) {
                const event = this.events.find(e => e.id === eventId);
                if (!event) return;
                this.eventDetailModal.dataset.eventId = eventId;
                document.getElementById('eventDetailTitle').textContent = event.name;
                document.getElementById('eventDetailTitle').style.color = event.color;
                this.renderEventPages(event);
                this.eventDetailModal.style.display = 'flex';
                this.eventDetailModal.classList.add('show');
            }

            renderEventPages(event) {
                const pagesList = document.getElementById('eventPagesList');
                if (event.pages.length === 0) {
                    pagesList.innerHTML = `
                        <div class="empty-state">
                            <i class="fas fa-file-alt"></i>
                            <h3>Nessuna pagina aggiunta</h3>
                            <p>Apri un PDF e clicca sul tasto + per aggiungere pagine</p>
                        </div>
                    `;
                } else {
                    pagesList.innerHTML = event.pages.map((page, index) => {
                        const title = page.title || `Pagina ${page.pageNumber}`;
                        const pdfName = page.pdfName || 'PDF Sconosciuto';
                        return `
                        <div class="event-item${this.selectedReorderPage === index ? ' selected' : ''}" style="display: flex; align-items: center;">
                            <div class="event-col-num" style="width: 32px; flex-shrink: 0; text-align: center;">${index + 1}</div>
                            <div class="event-col-check" style="width: 32px; flex-shrink: 0; display: flex; justify-content: center; align-items: center;">
                                <span class="reorder-checkbox${this.isReorderMode ? ' show' : ''}${this.selectedReorderPage === index ? ' checked' : ''}"
                                      style="${this.isReorderMode ? '' : 'visibility:hidden;'}"
                                      onclick="app.selectPageForReorder(${index})">
                                    ${this.selectedReorderPage === index ? '<i class=\"fas fa-check\"></i>' : ''}
                                </span>
                            </div>
                            <div class="event-col-content" style="flex: 1 1 0; min-width: 0;">
                                <div class="event-info">
                                    <h3><i class="fas fa-file-pdf"></i> ${title}</h3>
                                    <p>da "${pdfName}" - Pagina ${page.pageNumber}</p>
                                </div>
                            </div>
                            <div class="event-col-actions" style="width: 80px; flex-shrink: 0; display: flex; gap: 4px; justify-content: flex-end; align-items: center;">
                                <button class="btn btn-secondary btn-sm btn-icon" onclick="event.stopPropagation(); app.openPdfFromEventDetail('${event.id}', ${index})" title="Visualizza pagina">
                                    <i class="fas fa-eye"></i>
                                </button>
                                <button class="btn btn-danger btn-sm btn-icon" onclick="event.stopPropagation(); app.removePageFromEvent('${event.id}', ${index})" title="Rimuovi pagina">
                                    <i class="fas fa-trash"></i>
                                </button>
                            </div>
                        </div>
                    `;
                    }).join('');
                    // Pulsanti fissi di riordino
                    if (this.isReorderMode) {
                        let reorderFixed = document.getElementById('fixedReorderButtons');
                        if (!reorderFixed) {
                            reorderFixed = document.createElement('div');
                            reorderFixed.id = 'fixedReorderButtons';
                            reorderFixed.innerHTML = `
                                <button class="btn btn-secondary btn-lg" id="fixedMoveUpBtn" style="margin-bottom: 10px; width: 48px; height: 48px; display: block;">
                                    <i class="fas fa-chevron-up"></i>
                                </button>
                                <button class="btn btn-secondary btn-lg" id="fixedMoveDownBtn" style="width: 48px; height: 48px; display: block;">
                                    <i class="fas fa-chevron-down"></i>
                                </button>
                            `;
                            // Posiziona rispetto alla modale
                            const modal = document.getElementById('eventDetailModal');
                            reorderFixed.style.position = 'fixed';
                            reorderFixed.style.top = '50%';
                            reorderFixed.style.right = '40px';
                            reorderFixed.style.transform = 'translateY(-50%)';
                            reorderFixed.style.zIndex = '3001';
                            reorderFixed.style.display = 'flex';
                            reorderFixed.style.flexDirection = 'column';
                            reorderFixed.style.alignItems = 'center';
                            reorderFixed.style.pointerEvents = 'auto';
                            document.body.appendChild(reorderFixed);
                        }
                        // Gestione click
                        setTimeout(() => {
                            document.getElementById('fixedMoveUpBtn').onclick = () => {
                                if (this.selectedReorderPage !== null) this.movePageUp(this.selectedReorderPage);
                            };
                            document.getElementById('fixedMoveDownBtn').onclick = () => {
                                if (this.selectedReorderPage !== null) this.movePageDown(this.selectedReorderPage);
                            };
                        }, 0);
                    } else {
                        // Rimuovi se presenti
                        const existing = document.getElementById('fixedReorderButtons');
                        if (existing) existing.remove();
                    }
                }
            }

            toggleReorderMode() {
                this.isReorderMode = !this.isReorderMode;
                this.selectedReorderPage = null;
                const eventId = this.eventDetailModal.dataset.eventId;
                const event = this.events.find(e => e.id === eventId);
                if (event) {
                    this.renderEventPages(event);
                }
                const toggleBtn = document.getElementById('toggleReorderBtn');
                if (this.isReorderMode) {
                    toggleBtn.innerHTML = '<i class="fas fa-times"></i> Termina';
                    toggleBtn.classList.remove('btn-secondary');
                    toggleBtn.classList.add('btn-warning');
                } else {
                    toggleBtn.innerHTML = '<i class="fas fa-sort"></i> Cambia Ordine';
                    toggleBtn.classList.remove('btn-warning');
                    toggleBtn.classList.add('btn-secondary');
                }
            }

            selectPageForReorder(index) {
                if (!this.isReorderMode) return;
                this.selectedReorderPage = this.selectedReorderPage === index ? null : index;
                const eventId = this.eventDetailModal.dataset.eventId;
                const event = this.events.find(e => e.id === eventId);
                if (event) {
                    this.renderEventPages(event);
                }
            }

            async movePageUp(index) {
                if (!this.isReorderMode || index === 0) return;
                const eventId = this.eventDetailModal.dataset.eventId;
                const event = this.events.find(e => e.id === eventId);
                if (!event) return;
                
                // Swap pages
                [event.pages[index], event.pages[index - 1]] = [event.pages[index - 1], event.pages[index]];
                
                // Update selected index
                if (this.selectedReorderPage === index) {
                    this.selectedReorderPage = index - 1;
                } else if (this.selectedReorderPage === index - 1) {
                    // If the page above was selected, it's now at index
                    this.selectedReorderPage = index;
                }
                 // Deselect if we moved the only selected page past another
                 if (this.selectedReorderPage !== null && this.selectedReorderPage !== index && this.selectedReorderPage !== index - 1) {
                     this.selectedReorderPage = null;
                 }

                await this.saveData();
                this.renderEventPages(event);
                this.showToast('Ordine aggiornato');
            }

            async movePageDown(index) {
                const eventId = this.eventDetailModal.dataset.eventId;
                const event = this.events.find(e => e.id === eventId);
                if (!this.isReorderMode || !event || index === event.pages.length - 1) return;
                
                // Swap pages
                [event.pages[index], event.pages[index + 1]] = [event.pages[index + 1], event.pages[index]];
                
                // Update selected index
                if (this.selectedReorderPage === index) {
                    this.selectedReorderPage = index + 1;
                } else if (this.selectedReorderPage === index + 1) {
                     // If the page below was selected, it's now at index
                    this.selectedReorderPage = index;
                }
                 // Deselect if we moved the only selected page past another
                if (this.selectedReorderPage !== null && this.selectedReorderPage !== index && this.selectedReorderPage !== index + 1) {
                    this.selectedReorderPage = null;
                }

                await this.saveData();
                this.renderEventPages(event);
                this.showToast('Ordine aggiornato');
            }


            async removePageFromEvent(eventId, pageIndex) {
                if (confirm('Sei sicuro di voler rimuovere questa pagina dalla scaletta?')) {
                    const event = this.events.find(e => e.id === eventId);
                    if (!event) return;
                    event.pages.splice(pageIndex, 1);
                    await this.saveData();
                    this.renderEventPages(event);
                    this.renderEventsList();
                    this.showToast('Pagina rimossa dalla scaletta');
                }
            }

            hideEventDetailModal() {
                this.eventDetailModal.classList.remove('show');
                setTimeout(() => {
                    this.eventDetailModal.style.display = 'none';
                    this.eventDetailModal.dataset.eventId = '';
                    this.isReorderMode = false;
                    this.selectedReorderPage = null;
                     // Reset reorder button state
                    const toggleBtn = document.getElementById('toggleReorderBtn');
                    toggleBtn.innerHTML = '<i class="fas fa-sort"></i> Cambia Ordine';
                    toggleBtn.classList.remove('btn-warning');
                    toggleBtn.classList.add('btn-secondary');
                }, 300);
            }

            openPdfFromEventDetail(eventId, pageIndex) {
                this.hideEventDetailModal();
                this.startViewing({
                    type: 'event',
                    eventId: eventId,
                    pageIndex: pageIndex
                });
            }

            startViewingEvent(eventId) {
                this.hideEventDetailModal();
                this.startViewing({
                    type: 'event',
                    eventId: eventId,
                    pageIndex: 0
                });
            }

            // Add page to event
            async showAddToEventModal() {
                if (!this.currentPdf || !this.pdfDoc) return;
                await this.preparePageInfoForEvent();
                const eventsListContainer = document.getElementById('eventSelectList');
                if (this.events.length === 0) {
                    eventsListContainer.innerHTML = '<p>Nessun evento disponibile. Crea un nuovo evento qui sotto.</p>';
                } else {
                    eventsListContainer.innerHTML = this.events.map(event => `
                        <div class="event-item" onclick="app.addPageToEvent('${event.id}')" style="border-color: ${event.color}">
                            <div class="event-info">
                                <h3 style="color: ${event.color}"><i class="fas fa-music"></i> ${event.name}</h3>
                                <p>${event.description || 'Nessuna descrizione'}</p>
                                <small>${event.pages.length} pagine in scaletta</small>
                            </div>
                        </div>
                    `).join('');
                }
                this.addPageModal.style.display = 'flex';
                this.addPageModal.classList.add('show');
            }

            async preparePageInfoForEvent() {
                if (!this.currentPdf || !this.pdfDoc) return;
                let extractedTitle = `Pagina ${this.currentPageNum}`;
                this.showLoading();
                try {
                    const page = await this.pdfDoc.getPage(this.currentPageNum);
                    const textContent = await page.getTextContent();
                    if (textContent.items.length > 0) {
                        // Prendi la y della primissima parola
                        const firstY = textContent.items[0].transform ? textContent.items[0].transform[5] : textContent.items[0].y;
                        const TOLLERANZA = 1.5;
                        // Prendi tutti gli item consecutivi con la stessa y (prima riga effettiva)
                        let firstLineItems = [];
                        for (let i = 0; i < textContent.items.length; i++) {
                            const item = textContent.items[i];
                            const y = item.transform ? item.transform[5] : item.y;
                            if (Math.abs(y - firstY) < TOLLERANZA) {
                                firstLineItems.push(item.str.trim());
                            } else {
                                break;
                            }
                        }
                        const firstLineText = firstLineItems.join(' ').replace(/\s+/g, ' ').trim();
                        if (firstLineText.length > 0) {
                            extractedTitle = firstLineText.length > 60 ? firstLineText.substring(0, 57) + '...' : firstLineText;
                        }
                    }
                } catch (error) {
                    console.error('Error extracting text for title:', error);
                } finally {
                    this.hideLoading();
                }
                this.pageInfoFromViewer = {
                    pdfId: this.currentPdf.id,
                    pdfName: this.currentPdf.name,
                    pageNumber: this.currentPageNum,
                    title: extractedTitle
                };
            }

            hideAddPageModal() {
                this.addPageModal.classList.remove('show');
                setTimeout(() => {
                    this.addPageModal.style.display = 'none';
                }, 300);
            }

            async addPageToEvent(eventId) {
                if (!this.pageInfoFromViewer) return;
                const event = this.events.find(e => e.id === eventId);
                if (!event) return;
                const pageExists = event.pages.some(page =>
                    page.pdfId === this.pageInfoFromViewer.pdfId &&
                    page.pageNumber === this.pageInfoFromViewer.pageNumber
                );
                if (pageExists) {
                    this.showToast('Pagina già presente nella scaletta dell\'evento', 'warning');
                    this.hideAddPageModal();
                    return;
                }
                event.pages.push(this.pageInfoFromViewer);
                try {
                    await this.saveData();
                    this.hideAddPageModal();
                    this.showToast(`Pagina "${this.pageInfoFromViewer.title}" aggiunta a "${event.name}"`);
                    this.renderEventsList();
                } catch (error) {
                    console.error("Error adding page to event during save:", error);
                    this.hideAddPageModal();
                }
            }

            // Search functionality
            async searchInPdf(query) {
                if (!this.pdfDoc || !this.currentPdf) return;

                // Clear previous search
                this.clearSearchResults();
                this.clearTextHighlights();

                if (query.length < 2) {
                    this.hideSearchResults();
                    return;
                }

                // Show loading state
                this.showSearchLoading();
                this.pdfSearchInput.classList.add('searching');

                try {
                    const searchResults = [];
                    const searchQuery = query.toLowerCase();
                    const pdfId = this.currentPdf.id;
                    const indexEntry = this.searchIndex && this.searchIndex[pdfId];
                    if (!indexEntry) {
                        this.showToast('PDF non indicizzato. Premi "Ricostruisci Indice Ricerca".', 'warning');
                        this.hideSearchLoading();
                        this.pdfSearchInput.classList.remove('searching');
                        return;
                    }
                    for (const page of indexEntry.pages) {
                        const pageText = page.text;
                        const lowerPageText = pageText.toLowerCase();
                        let startIndex = 0;
                        while (true) {
                            const index = lowerPageText.indexOf(searchQuery, startIndex);
                            if (index === -1) break;
                            searchResults.push({
                                pageNumber: page.page,
                                matchIndex: index,
                                context: pageText.substring(Math.max(0, index - 30), index + query.length + 30)
                            });
                            startIndex = index + 1;
                        }
                    }
                    this.displaySearchResultsFast(searchResults, searchQuery);
                    setTimeout(() => {
                        if (this.pdfSearchInput) this.pdfSearchInput.focus();
                    }, 10);
                } catch (error) {
                    console.error('Error searching PDF:', error);
                    this.showToast('Errore durante la ricerca', 'error');
                } finally {
                    this.hideSearchLoading();
                    this.pdfSearchInput.classList.remove('searching');
                }
            }

            displaySearchResultsFast(results, query) {
                this.hideSearchLoading();
                
                if (results.length === 0) {
                    this.searchNoResults.style.display = 'block';
                    this.searchResultsList.innerHTML = '';
                    this.searchNavigation.style.display = 'none';
                    // Mostra sempre il contatore, anche quando non ci sono risultati
                    this.searchCount.textContent = '0 ris./0 pag.';
                    this.showSearchResults();
                    return;
                }

                this.searchNoResults.style.display = 'none';
                
                // Display results
                this.searchResultsList.innerHTML = results.map((result, index) => {
                    const highlightedContext = result.context.replace(
                        new RegExp(query, 'gi'),
                        match => `<span class=\"highlight\">${match}</span>`
                    );
                    return `
                        <div class=\"search-result-item\" data-index=\"${index}\" onclick=\"app.goToSearchResult(${index})\">
                            <div class=\"search-result-page\">Pagina ${result.pageNumber}</div>
                            <div class=\"search-result-text\">${highlightedContext}</div>
                        </div>
                    `;
                }).join('');

                // Calcola pagine uniche
                const uniquePages = new Set(results.map(r => r.pageNumber)).size;
                
                // Scritta compatta: '27 ris./11 pag.'
                this.searchCount.textContent = `${results.length} ris./${uniquePages} pag.`;
                this.searchNavigation.style.display = 'flex';
                this.currentSearchResults = results;
                this.currentSearchIndex = 0;
                
                this.showSearchResults();
                this.highlightCurrentSearchResult();
                
                // Aggiungi gestori di eventi specifici per i risultati di ricerca
                this.addSearchResultEventListeners();
            }

            addSearchResultEventListeners() {
                // Rimuovi gestori precedenti
                const searchItems = document.querySelectorAll('.search-result-item');
                searchItems.forEach(item => {
                    // Rimuovi tutti gli event listener esistenti
                    const newItem = item.cloneNode(true);
                    item.parentNode.replaceChild(newItem, item);
                });
                
                // Gestore per il pulsante di chiusura in modalità portrait
                const searchResults = document.querySelector('.search-results');
                if (searchResults) {
                    // Gestore per il pulsante di chiusura (::after pseudo-element)
                    searchResults.addEventListener('click', (e) => {
                        // Calcola se il click è nell'area del pulsante di chiusura
                        const rect = searchResults.getBoundingClientRect();
                        const clickX = e.clientX - rect.left;
                        const clickY = e.clientY - rect.top;
                        
                        // Il pulsante è posizionato in alto a destra
                        if (clickX > rect.width - 70 && clickY < 70) {
                            this.hideSearchResults();
                        }
                    });
                    
                    // Gestore per il touch del pulsante di chiusura
                    searchResults.addEventListener('touchstart', (e) => {
                        const rect = searchResults.getBoundingClientRect();
                        const touchX = e.touches[0].clientX - rect.left;
                        const touchY = e.touches[0].clientY - rect.top;
                        
                        // Se il touch è sul pulsante di chiusura
                        if (touchX > rect.width - 70 && touchY < 70) {
                            e.stopPropagation();
                            e.preventDefault();
                            this.hideSearchResults();
                            return;
                        }
                        
                        // Altrimenti permetti lo scroll normale
                        e.stopPropagation();
                    }, { passive: false });
                    
                    // Permetti lo scroll normale per il resto dell'area
                    searchResults.addEventListener('touchmove', (e) => {
                        e.stopPropagation();
                    }, { passive: false });
                }
                
                // Sistema di scrolling touch personalizzato per mobile
                const searchResultsList = document.getElementById('searchResultsList');
                if (searchResultsList && window.innerWidth <= 768) {
                    let isScrolling = false;
                    let startY = 0;
                    let startScrollTop = 0;
                    let hasMoved = false;
                    
                    searchResultsList.addEventListener('touchstart', (e) => {
                        // Se il touch è su un risultato, gestisci il click
                        if (e.target.closest('.search-result-item')) {
                            const item = e.target.closest('.search-result-item');
                            const index = parseInt(item.dataset.index);
                            
                            // Imposta un timeout per distinguere tra click e scroll
                            setTimeout(() => {
                                if (!hasMoved) {
                                    this.goToSearchResult(index);
                                }
                            }, 150);
                            
                            return;
                        }
                        
                        // Altrimenti inizia lo scrolling
                        isScrolling = true;
                        hasMoved = false;
                        startY = e.touches[0].clientY;
                        startScrollTop = searchResultsList.scrollTop;
                        e.preventDefault();
                    }, { passive: false });
                    
                    searchResultsList.addEventListener('touchmove', (e) => {
                        if (!isScrolling) return;
                        
                        const deltaY = e.touches[0].clientY - startY;
                        
                        // Se il movimento è significativo, considera che è uno scroll
                        if (Math.abs(deltaY) > 5) {
                            hasMoved = true;
                        }
                        
                        searchResultsList.scrollTop = startScrollTop - deltaY;
                        e.preventDefault();
                    }, { passive: false });
                    
                    searchResultsList.addEventListener('touchend', () => {
                        isScrolling = false;
                        hasMoved = false;
                    });
                    
                    // Forza la visualizzazione della scrollbar su mobile
                    searchResultsList.style.overflowY = 'scroll';
                    searchResultsList.style.webkitOverflowScrolling = 'touch';
                }
                
                // BLOCCO COMPLETO DELL'INPUT TOUCH AL DI FUORI DELLA RICERCA
                this.blockTouchOutsideSearch();
            }
            
            blockTouchOutsideSearch() {
                // Rimuovi eventuali gestori precedenti
                if (this.touchBlocker) {
                    document.body.removeEventListener('touchstart', this.touchBlocker, { passive: false });
                    document.body.removeEventListener('touchmove', this.touchBlocker, { passive: false });
                    document.body.removeEventListener('touchend', this.touchBlocker, { passive: false });
                }
                
                // Crea il gestore che blocca il touch
                this.touchBlocker = (e) => {
                    // Permetti il touch solo su:
                    // 1. La finestra di ricerca
                    // 2. La barra di ricerca in alto
                    // 3. Il pulsante di chiusura
                    
                    const target = e.target;
                    const searchResults = document.querySelector('.search-results');
                    const searchInput = document.getElementById('searchInput');
                    const searchBtn = document.getElementById('searchBtn');
                    
                    // Controlla se il touch è su elementi permessi
                    const isOnSearchResults = searchResults && (searchResults.contains(target) || searchResults === target);
                    const isOnSearchInput = searchInput && (searchInput.contains(target) || searchInput === target);
                    const isOnSearchBtn = searchBtn && (searchBtn.contains(target) || searchBtn === target);
                    
                    // Se non è su nessun elemento permesso, blocca il touch
                    if (!isOnSearchResults && !isOnSearchInput && !isOnSearchBtn) {
                        e.preventDefault();
                        e.stopPropagation();
                        return false;
                    }
                };
                
                // Aggiungi i gestori al body per bloccare tutto
                document.body.addEventListener('touchstart', this.touchBlocker, { passive: false });
                document.body.addEventListener('touchmove', this.touchBlocker, { passive: false });
                document.body.addEventListener('touchend', this.touchBlocker, { passive: false });
            }
            
            unblockTouchOutsideSearch() {
                // Rimuovi i gestori di blocco
                if (this.touchBlocker) {
                    document.body.removeEventListener('touchstart', this.touchBlocker, { passive: false });
                    document.body.removeEventListener('touchmove', this.touchBlocker, { passive: false });
                    document.body.removeEventListener('touchend', this.touchBlocker, { passive: false });
                    this.touchBlocker = null;
                }
            }

            showSearchResults() {
                this.searchResults.classList.add('show');
                // Aggiungi listener per chiusura su overlay e X
                if (!this._searchModalListenersAdded) {
                    this._searchModalListenersAdded = true;
                    // Clic su overlay fuori dalla lista risultati
                    this.searchResults.addEventListener('click', (e) => {
                        if (e.target === this.searchResults) {
                            this.hideSearchResults();
                        }
                    });
                    // Clic su X
                    const closeBtn = this.searchResults.querySelector('.search-clear');
                    if (closeBtn) {
                        closeBtn.addEventListener('click', (e) => {
                            e.stopPropagation();
                            this.clearSearch();
                        });
                    }
                }
            }

            hideSearchResults() {
                this.searchResults.classList.remove('show');
                // Rimuovi il blocco touch quando si chiude la ricerca
                this.unblockTouchOutsideSearch();
                // Forza il focus e la selezione dell'input per permettere la cancellazione manuale su iPad
                setTimeout(() => {
                    this.pdfSearchInput.blur();
                }, 100);
            }

            showSearchLoading() {
                this.searchLoading.style.display = 'block';
                this.searchNoResults.style.display = 'none';
                this.searchResultsList.innerHTML = '';
                this.searchNavigation.style.display = 'none';
                this.showSearchResults();
            }

            hideSearchLoading() {
                this.searchLoading.style.display = 'none';
            }

            clearSearchResults() {
                this.searchResultsList.innerHTML = '';
                this.searchNoResults.style.display = 'none';
                this.searchLoading.style.display = 'none';
                this.searchNavigation.style.display = 'none';
                this.currentSearchResults = null;
                this.currentSearchIndex = 0;
            }

            clearTextHighlights() {
                this.textHighlightsContainer.innerHTML = '';
            }

            clearSearch() {
                this.pdfSearchInput.value = '';
                this.clearSearchResults();
                this.clearTextHighlights();
                this.hideSearchResults();
                this.pdfSearchInput.classList.remove('searching');
                // Rimuovi il blocco touch quando si cancella la ricerca
                this.unblockTouchOutsideSearch();
                // Forza il focus e la selezione dell'input per permettere la cancellazione manuale su iPad
                setTimeout(() => {
                    this.pdfSearchInput.blur();
                    this.pdfSearchInput.value = '';
                }, 100);
            }

            goToSearchResult(index) {
                if (!this.currentSearchResults || index < 0 || index >= this.currentSearchResults.length) return;
                
                // Evita doppi click/touch
                if (this.searchResultClickTimeout) {
                    clearTimeout(this.searchResultClickTimeout);
                }
                
                this.searchResultClickTimeout = setTimeout(() => {
                    const result = this.currentSearchResults[index];
                    this.currentSearchIndex = index;
                    
                    // Go to the page
                    this.goToPage(result.pageNumber);
                    
                    // Highlight the result
                    this.highlightCurrentSearchResult();
                    
                    this.searchResultClickTimeout = null;
                }, 100);
            }

            nextSearchResult() {
                if (!this.currentSearchResults || this.currentSearchResults.length === 0) return;
                
                this.currentSearchIndex = (this.currentSearchIndex + 1) % this.currentSearchResults.length;
                this.goToSearchResult(this.currentSearchIndex);
            }

            prevSearchResult() {
                if (!this.currentSearchResults || this.currentSearchResults.length === 0) return;
                
                this.currentSearchIndex = this.currentSearchIndex === 0 ? 
                    this.currentSearchResults.length - 1 : this.currentSearchIndex - 1;
                this.goToSearchResult(this.currentSearchIndex);
            }

            highlightCurrentSearchResult() {
                // Remove previous highlights
                document.querySelectorAll('.search-result-item').forEach(item => {
                    item.classList.remove('active');
                });
                
                // Add highlight to current result
                const currentItem = document.querySelector(`.search-result-item[data-index="${this.currentSearchIndex}"]`);
                if (currentItem) {
                    currentItem.classList.add('active');
                    currentItem.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
                }
            }

            // Wake Lock methods
            async requestWakeLock() {
                try {
                    if ('wakeLock' in navigator) {
                        this.wakeLock = await navigator.wakeLock.request('screen');
                        console.log('Wake Lock attivato - lo schermo rimarrà acceso');
                        this.wakeLock.addEventListener('release', () => {
                            console.log('Wake Lock rilasciato automaticamente');
                            this.wakeLock = null;
                        });
                    } else {
                        console.log('Wake Lock API non supportata su questo dispositivo');
                    }
                } catch (err) {
                    console.error('Errore nell\'attivazione del Wake Lock:', err);
                }
            }

            releaseWakeLock() {
                if (this.wakeLock) {
                    this.wakeLock.release();
                    this.wakeLock = null;
                    console.log('Wake Lock rilasciato - lo schermo può spegnersi normalmente');
                }
            }

            // Utility functions
            formatFileSize(bytes) {
                if (bytes === 0) return '0 Bytes';
                const k = 1024;
                const sizes = ['Bytes', 'KB', 'MB', 'GB'];
                const i = Math.floor(Math.log(bytes) / Math.log(k));
                return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
            }

            showToast(message, type = 'success', duration = 3000) {
                document.querySelectorAll('.toast').forEach(toast => toast.remove());
                const toast = document.createElement('div');
                toast.className = `toast ${type}`;
                toast.textContent = message;
                document.body.appendChild(toast);
                requestAnimationFrame(() => {
                    toast.classList.add('show');
                });
                setTimeout(() => {
                    toast.classList.remove('show');
                    toast.addEventListener('transitionend', () => {
                        toast.remove();
                    }, { once: true });
                }, duration);
            }

            showLoading() {
                const loadingElement = document.getElementById('loading');
                if (loadingElement) {
                    loadingElement.style.display = 'flex';
                }
            }

            hideLoading() {
                const loadingElement = document.getElementById('loading');
                if (loadingElement) {
                    loadingElement.style.display = 'none';
                }
            }

            async saveData() {
                try {
                    const db = await this.openDB();
                    const transaction = db.transaction(['pdfs', 'events'], 'readwrite');
                    const pdfsStore = transaction.objectStore('pdfs');
                    const eventsStore = transaction.objectStore('events');
                    
                    // Clear existing data before saving the current state
                    await new Promise((resolve, reject) => {
                        const req = pdfsStore.clear();
                        req.onsuccess = () => resolve();
                        req.onerror = () => reject(req.error);
                    });
                    
                    for (const pdf of this.pdfs) {
                        await new Promise((resolve, reject) => {
                            const req = pdfsStore.put(pdf);
                            req.onsuccess = () => resolve();
                            req.onerror = () => reject(req.error);
                        });
                    }
                    
                    await new Promise((resolve, reject) => {
                        const req = eventsStore.clear();
                        req.onsuccess = () => resolve();
                        req.onerror = () => reject(req.error);
                    });
                    
                    for (const event of this.events) {
                        await new Promise((resolve, reject) => {
                            const req = eventsStore.put(event);
                            req.onsuccess = () => resolve();
                            req.onerror = () => reject(req.error);
                        });
                    }
                    
                    await new Promise((resolve, reject) => {
                        transaction.oncomplete = () => resolve();
                        transaction.onerror = (err) => reject(err);
                        transaction.onabort = (err) => reject(err);
                    });
                     console.log("Data saved successfully to IndexedDB.");
                } catch (error) {
                    console.error('Error saving data to IndexedDB:', error);
                    this.showToast('Errore nel salvataggio dati.', 'error');
                    throw error;
                }
            }

            // --- Modals ---
            showHelpModal() {
                this.helpModal.style.display = 'flex';
                this.helpModal.classList.add('show');
            }

            hideHelpModal() {
                this.helpModal.classList.remove('show');
                setTimeout(() => {
                    this.helpModal.style.display = 'none';
                }, 300);
            }
            // ---------------

            updateTransform() {
                // Apply transform to the wrapper, so canvas and overlays move together.
                this.pdfContentWrapper.style.transform = `translate(${this.pan.x}px, ${this.pan.y}px) scale(${this.zoomLevel})`;
            }

            getMidpoint(t1, t2) {
                return {
                    x: (t1.clientX + t2.clientX) / 2,
                    y: (t1.clientY + t2.clientY) / 2
                };
            }

            // Annotation Methods
            toggleAnnotationMode() {
                this.annotationState.isActive = !this.annotationState.isActive;
                this.annotationToggle.classList.toggle('active', this.annotationState.isActive);
                this.annotationTools.classList.toggle('show', this.annotationState.isActive);
                if (this.annotationState.isActive) {
                    // Carica le annotazioni solo se non ci sono già contenuti visibili
                    const hasVisibleContent = this.annotationState.stickyNotes.length > 0 || 
                        (this.drawingCanvas.classList.contains('active') && this.drawingCanvas.width > 0);
                    
                    if (!hasVisibleContent) {
                        // Solo se non ci sono contenuti visibili, carica le annotazioni
                        this.loadPageAnnotations();
                    }
                    this.startAutoSaveAnnotations();
                } else {
                    this.stopAutoSaveAnnotations();
                }
            }

            selectAnnotationTool(tool) {
                this.annotationState.currentTool = tool;
                this.updateAnnotationToolUI();
                
                if (tool === 'note') {
                    this.createStickyNote();
                } else if (tool === 'eraser') {
                    this.undoLastDrawing();
                    // Non resettare currentTool, mantieni lo strumento selezionato
                    // this.annotationState.currentTool = null;
                    // this.updateAnnotationToolUI();
                }
            }

            updateAnnotationToolUI() {
                // Remove active class from all tools
                this.penTool.classList.remove('active');
                this.eraserTool.classList.remove('active');
                this.noteTool.classList.remove('active');
                
                // Add active class to current tool
                if (this.annotationState.currentTool) {
                    document.getElementById(`${this.annotationState.currentTool}Tool`).classList.add('active');
                }
            }

            handleDrawingStart(e) {
                if (!this.annotationState.isActive || this.annotationState.currentTool !== 'pen') return;
                
                e.preventDefault();
                const { x, y } = this.getCanvasRelativeCoords(e);
                
                // Se ci sono schizzi importati e si inizia a disegnare, 
                // imposta il flag per tracciare che ci sono schizzi importati sotto quelli in sessione
                if (this.annotationState.hasImportedDrawing && !this.annotationState.hasImportedDrawingUnderSession) {
                    this.annotationState.hasImportedDrawingUnderSession = true;
                }
                
                this.annotationState.isDrawing = true;
                this.annotationState.lastX = x;
                this.annotationState.lastY = y;
                
                // Start new path
                this.annotationState.drawingCtx.beginPath();
                this.annotationState.drawingCtx.moveTo(x, y);
                this.annotationState.drawingCtx.strokeStyle = '#ef4444';
                this.annotationState.drawingCtx.lineWidth = 3;
                this.annotationState.drawingCtx.lineCap = 'round';
                this.annotationState.drawingCtx.lineJoin = 'round';
            }

            handleDrawingMove(e) {
                if (!this.annotationState.isActive || !this.annotationState.isDrawing || this.annotationState.currentTool !== 'pen') return;
                
                e.preventDefault();
                const { x, y } = this.getCanvasRelativeCoords(e);
                
                this.annotationState.drawingCtx.lineTo(x, y);
                this.annotationState.drawingCtx.stroke();
                
                this.annotationState.lastX = x;
                this.annotationState.lastY = y;
            }

            handleDrawingEnd(e) {
                if (!this.annotationState.isDrawing) return;
                this.annotationState.isDrawing = false;
                this.saveDrawingToHistory();
                this.savePageAnnotations();
            }

            saveDrawingToHistory() {
                // Save current canvas state to history for undo
                const imageData = this.annotationState.drawingCtx.getImageData(0, 0, this.drawingCanvas.width, this.drawingCanvas.height);
                this.annotationState.drawingHistory.push(imageData);
                
                // Limit history to prevent memory issues
                if (this.annotationState.drawingHistory.length > 20) {
                    this.annotationState.drawingHistory.shift();
                }
            }

            undoLastDrawing() {
                // Se ci sono operazioni di disegno in sessione, cancella l'ultima
                if (this.annotationState.drawingHistory.length > 0) {
                    // Remove last drawing operation
                    this.annotationState.drawingHistory.pop();
                    
                    // Clear canvas and redraw
                    this.annotationState.drawingCtx.clearRect(0, 0, this.drawingCanvas.width, this.drawingCanvas.height);
                    
                    // Redraw all remaining operations
                    this.annotationState.drawingHistory.forEach(imageData => {
                        this.annotationState.drawingCtx.putImageData(imageData, 0, 0);
                    });
                    
                    // Salva lo stato dopo la cancellazione
                    this.savePageAnnotations();
                    return;
                }
                
                // Se non ci sono operazioni di disegno in sessione ma ci sono schizzi importati sotto
                if (this.annotationState.hasImportedDrawingUnderSession) {
                    // Cancella tutto il canvas (schizzi importati)
                    this.annotationState.drawingCtx.clearRect(0, 0, this.drawingCanvas.width, this.drawingCanvas.height);
                    this.drawingCanvas.classList.remove('active');
                    this.annotationState.hasImportedDrawing = false;
                    this.annotationState.hasImportedDrawingUnderSession = false;
                    // Salva lo stato vuoto
                    this.savePageAnnotations();
                    return;
                }
                
                // Se non ci sono operazioni di disegno in sessione ma ci sono schizzi importati (senza disegni sopra)
                if (this.annotationState.hasImportedDrawing) {
                    // Cancella tutto il canvas (schizzi importati)
                    this.annotationState.drawingCtx.clearRect(0, 0, this.drawingCanvas.width, this.drawingCanvas.height);
                    this.drawingCanvas.classList.remove('active');
                    this.annotationState.hasImportedDrawing = false;
                    // Salva lo stato vuoto
                    this.savePageAnnotations();
                    return;
                }
                
                // Se non c'è nulla da cancellare, non fare nulla
            }

            createStickyNote() {
                const note = document.createElement('div');
                note.className = 'sticky-note';
                note.style.left = '50px';
                note.style.top = '50px';
                note.tabIndex = 0;
                // Header con X e testo inline
                const header = document.createElement('div');
                header.className = 'sticky-note-header';
                // X
                const closeBtn = document.createElement('button');
                closeBtn.className = 'sticky-note-close';
                closeBtn.innerHTML = '<i class="fas fa-times"></i>';
                closeBtn.onclick = () => this.removeStickyNote(note);
                closeBtn.addEventListener('touchstart', (e) => { e.stopPropagation(); e.preventDefault(); this.removeStickyNote(note); }, { passive: false });
                header.appendChild(closeBtn);
                // Testo inline
                const content = document.createElement('textarea');
                content.className = 'sticky-note-content';
                content.placeholder = 'Scrivi una nota...';
                content.oninput = () => this.saveStickyNoteContent(note, content.value);
                content.addEventListener('mousedown', e => { e.stopPropagation(); });
                content.addEventListener('touchstart', e => { e.stopPropagation(); });
                header.appendChild(content);
                note.appendChild(header);
                // Icone drag/resize
                const icons = document.createElement('div');
                icons.className = 'sticky-note-icons';
                // Drag
                const moveIcon = document.createElement('span');
                moveIcon.className = 'sticky-note-move';
                moveIcon.innerHTML = '&#9776;'; // ☰
                icons.appendChild(moveIcon);
                note.appendChild(icons);
                // Solo resize in basso a sinistra - aggiunto direttamente alla nota
                const resizeIcon = document.createElement('span');
                resizeIcon.className = 'sticky-note-resize';
                resizeIcon.innerHTML = '&#8600;'; // ↘
                note.appendChild(resizeIcon);
                this.stickyNotesContainer.appendChild(note);
                this.annotationState.stickyNotes.push(note);
                // Drag
                this.makeNoteDraggable(note, moveIcon);
                // Resize
                this.makeNoteResizable(note, resizeIcon);
                if (window.ResizeObserver) {
                    const resizeObserver = new ResizeObserver(() => {
                        this.savePageAnnotations();
                    });
                    resizeObserver.observe(note);
                    note._resizeObserver = resizeObserver;
                }
                setTimeout(() => content.focus(), 100);
                this.savePageAnnotations();
            }
            createStickyNoteFromData(noteData) {
                const note = document.createElement('div');
                note.className = 'sticky-note';
                note.style.left = noteData.left || '50px';
                note.style.top = noteData.top || '50px';
                if (noteData.width) note.style.width = noteData.width;
                if (noteData.height) note.style.height = noteData.height;
                note.tabIndex = 0;
                // Header con X e testo inline
                const header = document.createElement('div');
                header.className = 'sticky-note-header';
                // X
                const closeBtn = document.createElement('button');
                closeBtn.className = 'sticky-note-close';
                closeBtn.innerHTML = '<i class="fas fa-times"></i>';
                closeBtn.onclick = () => this.removeStickyNote(note);
                closeBtn.addEventListener('touchstart', (e) => { e.stopPropagation(); e.preventDefault(); this.removeStickyNote(note); }, { passive: false });
                header.appendChild(closeBtn);
                // Testo inline
                const content = document.createElement('textarea');
                content.className = 'sticky-note-content';
                content.value = noteData.content || '';
                content.oninput = () => this.saveStickyNoteContent(note, content.value);
                content.addEventListener('mousedown', e => { e.stopPropagation(); });
                content.addEventListener('touchstart', e => { e.stopPropagation(); });
                header.appendChild(content);
                note.appendChild(header);
                note.dataset.content = noteData.content || '';
                // Icone drag/resize
                const icons = document.createElement('div');
                icons.className = 'sticky-note-icons';
                // Drag
                const moveIcon = document.createElement('span');
                moveIcon.className = 'sticky-note-move';
                moveIcon.innerHTML = '&#9776;'; // ☰
                icons.appendChild(moveIcon);
                note.appendChild(icons);
                // Solo resize in basso a sinistra - aggiunto direttamente alla nota
                const resizeIcon = document.createElement('span');
                resizeIcon.className = 'sticky-note-resize';
                resizeIcon.innerHTML = '&#8600;'; // ↘
                note.appendChild(resizeIcon);
                this.stickyNotesContainer.appendChild(note);
                this.annotationState.stickyNotes.push(note);
                this.makeNoteDraggable(note, moveIcon);
                this.makeNoteResizable(note, resizeIcon);
                if (window.ResizeObserver) {
                    const resizeObserver = new ResizeObserver(() => {
                        this.savePageAnnotations();
                    });
                    resizeObserver.observe(note);
                    note._resizeObserver = resizeObserver;
                }
            }
            makeNoteResizable(note, resizeIcon) {
                let isResizing = false;
                let startX, startY, startW, startH;
                const startResize = (e) => {
                    isResizing = true;
                    startX = e.type.startsWith('touch') ? e.touches[0].clientX : e.clientX;
                    startY = e.type.startsWith('touch') ? e.touches[0].clientY : e.clientY;
                    startW = parseInt(note.style.width) || note.offsetWidth;
                    startH = parseInt(note.style.height) || note.offsetHeight;
                    note.style.userSelect = 'none';
                    e.preventDefault();
                    e.stopPropagation();
                    document.onmousemove = doResize;
                    document.onmouseup = stopResize;
                    document.ontouchmove = doResize;
                    document.ontouchend = stopResize;
                };
                const doResize = (e) => {
                    if (!isResizing) return;
                    const clientX = e.type.startsWith('touch') ? e.touches[0].clientX : e.clientX;
                    const clientY = e.type.startsWith('touch') ? e.touches[0].clientY : e.clientY;
                    let newW = Math.max(48, startW + (clientX - startX));
                    let newH = Math.max(24, startH + (clientY - startY));
                    note.style.width = newW + 'px';
                    note.style.height = newH + 'px';
                    
                    // Calcola dimensione font proporzionale
                    const baseFontSize = 13; // Dimensione base
                    const baseWidth = 100; // Larghezza base di riferimento
                    const baseHeight = 50; // Altezza base di riferimento
                    
                    // Calcola proporzione basata su larghezza e altezza
                    const widthRatio = newW / baseWidth;
                    const heightRatio = newH / baseHeight;
                    const ratio = Math.min(widthRatio, heightRatio); // Usa il rapporto minore per evitare testo troppo grande
                    
                    // Limita la dimensione del font tra 10px e 20px
                    const newFontSize = Math.max(10, Math.min(20, baseFontSize * ratio));
                    
                    // Applica la nuova dimensione del font
                    const content = note.querySelector('.sticky-note-content');
                    if (content) {
                        content.style.fontSize = newFontSize + 'px';
                    }
                    
                    // Ridimensiona proporzionalmente anche le icone
                    const closeBtn = note.querySelector('.sticky-note-close');
                    const moveIcon = note.querySelector('.sticky-note-move');
                    const resizeIcon = note.querySelector('.sticky-note-resize');
                    
                    // Calcola dimensioni icone proporzionali (tra 12px e 18px)
                    const iconSize = Math.max(12, Math.min(18, 16 * ratio));
                    const iconPadding = Math.max(2, Math.min(4, 3 * ratio));
                    
                    if (closeBtn) {
                        closeBtn.style.fontSize = (iconSize - 2) + 'px';
                        closeBtn.style.width = iconSize + 'px';
                        closeBtn.style.height = iconSize + 'px';
                        closeBtn.style.padding = iconPadding + 'px';
                    }
                    
                    if (moveIcon) {
                        moveIcon.style.fontSize = iconSize + 'px';
                        moveIcon.style.padding = iconPadding + 'px';
                    }
                    
                    if (resizeIcon) {
                        resizeIcon.style.fontSize = (iconSize - 2) + 'px';
                        resizeIcon.style.width = iconSize + 'px';
                        resizeIcon.style.height = iconSize + 'px';
                        resizeIcon.style.padding = iconPadding + 'px';
                    }
                };
                const stopResize = () => {
                    isResizing = false;
                    note.style.userSelect = '';
                    document.onmousemove = null;
                    document.onmouseup = null;
                    document.ontouchmove = null;
                    document.ontouchend = null;
                    this.savePageAnnotations();
                };
                if (resizeIcon) {
                    resizeIcon.onmousedown = (e) => startResize(e);
                    resizeIcon.ontouchstart = (e) => startResize(e);
                }
            }

            makeNoteDraggable(note) {
                let isDragging = false;
                let startX, startY, startLeft, startTop;
                
                const handleMouseDown = (e) => {
                    if (e.target.classList.contains('sticky-note-content') || e.target.classList.contains('sticky-note-close')) {
                        return; // Don't drag when clicking on content or close button
                    }
                    
                    isDragging = true;
                    // Usa coordinate del viewport e converti per le trasformazioni
                    startX = e.clientX;
                    startY = e.clientY;
                    startLeft = parseInt(note.style.left) || 0;
                    startTop = parseInt(note.style.top) || 0;
                    
                    note.style.cursor = 'grabbing';
                    e.preventDefault();
                };
                
                const handleMouseMove = (e) => {
                    if (!isDragging) return;
                    
                    // Calcola delta in coordinate del viewport
                    const deltaX = e.clientX - startX;
                    const deltaY = e.clientY - startY;
                    
                    // Applica le trasformazioni inverse per ottenere il movimento corretto
                    const newLeft = startLeft + (deltaX / this.zoomLevel);
                    const newTop = startTop + (deltaY / this.zoomLevel);
                    
                    note.style.left = newLeft + 'px';
                    note.style.top = newTop + 'px';
                    
                    // Salva solo al termine del drag
                };
                
                const handleMouseUp = () => {
                    if (isDragging) {
                        isDragging = false;
                        note.style.cursor = 'move';
                        this.savePageAnnotations();
                    }
                };
                
                note.addEventListener('mousedown', handleMouseDown);
                document.addEventListener('mousemove', handleMouseMove);
                document.addEventListener('mouseup', handleMouseUp);
                
                // Touch events for mobile
                note.addEventListener('touchstart', (e) => {
                    if (e.target.classList.contains('sticky-note-content') || e.target.classList.contains('sticky-note-close')) {
                        return;
                    }
                    
                    isDragging = true;
                    // Usa coordinate del viewport per touch
                    startX = e.touches[0].clientX;
                    startY = e.touches[0].clientY;
                    startLeft = parseInt(note.style.left) || 0;
                    startTop = parseInt(note.style.top) || 0;
                    
                    note.style.cursor = 'grabbing';
                    e.preventDefault();
                }, { passive: false });
                
                document.addEventListener('touchmove', (e) => {
                    if (!isDragging) return;
                    
                    // Calcola delta in coordinate del viewport per touch
                    const deltaX = e.touches[0].clientX - startX;
                    const deltaY = e.touches[0].clientY - startY;
                    
                    // Applica le trasformazioni inverse per ottenere il movimento corretto
                    const newLeft = startLeft + (deltaX / this.zoomLevel);
                    const newTop = startTop + (deltaY / this.zoomLevel);
                    
                    note.style.left = newLeft + 'px';
                    note.style.top = newTop + 'px';
                    
                    // Salva solo al termine del drag
                    e.preventDefault();
                }, { passive: false });
                
                document.addEventListener('touchend', handleMouseUp);
            }

            removeStickyNote(note) {
                const index = this.annotationState.stickyNotes.indexOf(note);
                if (index > -1) {
                    this.annotationState.stickyNotes.splice(index, 1);
                }
                note.remove();
                this.savePageAnnotations();
            }

            saveStickyNoteContent(note, content) {
                // Save content to note data attribute for persistence
                note.dataset.content = content;
                this.savePageAnnotations();
            }

            getCurrentPageKey() {
                if (this.isViewingEvent) {
                    return `event_${this.currentEventId}_${this.currentEventPageIndex}`;
                } else {
                    return `pdf_${this.currentPdf.id}_${this.currentPageNum}`;
                }
            }

            savePageAnnotations() {
                if (!this.currentPdf) return;
                const pageKey = this.getCurrentPageKey();
                // Save drawing data in PNG format to maintain transparency
                const drawingData = this.drawingCanvas.toDataURL('image/png');
                // Crea PNG di un canvas vuoto con stesse dimensioni
                let emptyCanvasData = null;
                if (this.drawingCanvas) {
                    const emptyCanvas = document.createElement('canvas');
                    emptyCanvas.width = this.drawingCanvas.width;
                    emptyCanvas.height = this.drawingCanvas.height;
                    emptyCanvasData = emptyCanvas.toDataURL('image/png');
                }
                // Save sticky notes data
                const notesData = this.annotationState.stickyNotes.map(note => ({
                    left: note.style.left,
                    top: note.style.top,
                    width: note.style.width,
                    height: note.style.height,
                    content: note.dataset.content || ''
                }));
                // Controllo se ci sono note non vuote
                const hasNotes = notesData.some(note => note.content && note.content.trim() !== '');
                // Controllo se ci sono disegni effettivi (drawingHistory O disegno nel canvas)
                const hasDrawingHistory = Array.isArray(this.annotationState.drawingHistory) && this.annotationState.drawingHistory.length > 0;
                // Il canvas è considerato "vuoto" se il PNG è identico a quello di un canvas vuoto
                const hasDrawingInCanvas = drawingData.length > 100 && drawingData !== emptyCanvasData;
                const hasDrawing = hasDrawingHistory || hasDrawingInCanvas;
                
                console.log('[DEBUG] savePageAnnotations per', pageKey, {
                    hasNotes: hasNotes,
                    hasDrawingHistory: hasDrawingHistory,
                    hasDrawingInCanvas: hasDrawingInCanvas,
                    hasDrawing: hasDrawing,
                    drawingDataLength: drawingData.length,
                    notesDataLength: notesData.length,
                    drawingHistoryLength: this.annotationState.drawingHistory.length,
                    emptyCanvasMatch: drawingData === emptyCanvasData
                });
                
                // Toast di debug per smartphone
                // this.showToast(`DEBUG SAVE: ${pageKey} - Notes: ${hasNotes}, Drawing: ${hasDrawing}, Canvas: ${hasDrawingInCanvas}`, 'info', 2000);
                
                if (hasNotes || hasDrawing) {
                    this.annotationState.currentPageAnnotations[pageKey] = {
                        drawing: drawingData,
                        notes: notesData,
                        drawingHistory: this.annotationState.drawingHistory
                    };
                    
                    // Aggiorna il flag hasImportedDrawing: se ci sono operazioni di disegno in sessione,
                    // non ci sono più schizzi importati da cancellare
                    if (hasDrawingHistory) {
                        // Non resettare hasImportedDrawing, mantieni traccia dello schizzo importato
                        // this.annotationState.hasImportedDrawing = false;
                        // Mantieni hasImportedDrawingUnderSession se era già impostato
                    }
                    
                    // Aggiorna modifiedPages
                    if (this.currentPdf) {
                        const pdfId = this.currentPdf.id;
                        const pageNum = this.currentPageNum;
                        this.annotationState.modifiedPages.add(`${pdfId}_${pageNum}`);
                    }
                    // Salva su IndexedDB
                    this.saveAnnotationsToStorage();
                    console.log('[DEBUG] Annotazioni salvate per', pageKey);
                } else {
                    // Se non ci sono annotazioni, elimina dalla memoria e dal DB
                    delete this.annotationState.currentPageAnnotations[pageKey];
                    this.annotationState.hasImportedDrawing = false;
                    this.annotationState.hasImportedDrawingUnderSession = false;
                    if (this.currentPdf) {
                        const pdfId = this.currentPdf.id;
                        const pageNum = this.currentPageNum;
                        this.annotationState.modifiedPages.delete(`${pdfId}_${pageNum}`);
                    }
                    this.deleteAnnotationFromStorage(pageKey);
                    console.log('[DEBUG] Annotazioni rimosse per', pageKey, '- nessun contenuto valido');
                }
            }

            // Funzione per comprimere le annotazioni durante l'esportazione
            compressAnnotationForExport(annotationData) {
                if (!annotationData || !annotationData.drawing) {
                    return annotationData;
                }

                // Usa una qualità di compressione fissa (30% - buon compromesso tra qualità e dimensione)
                const compressionQuality = 0.3;

                // Crea un canvas temporaneo per la compressione
                const tempCanvas = document.createElement('canvas');
                const tempCtx = tempCanvas.getContext('2d');
                const img = new Image();
                
                return new Promise((resolve) => {
                    img.onload = () => {
                        // Imposta le dimensioni del canvas temporaneo
                        tempCanvas.width = img.width;
                        tempCanvas.height = img.height;
                        
                        // Pulisci il canvas (mantiene trasparenza)
                        tempCtx.clearRect(0, 0, tempCanvas.width, tempCanvas.height);
                        
                        // Disegna l'immagine PNG (mantiene trasparenza)
                        tempCtx.drawImage(img, 0, 0);
                        
                        // Mantieni formato PNG per preservare la trasparenza
                        // Usa compressionQuality per determinare se comprimere o meno
                        const compressedData = compressionQuality < 1.0 
                            ? tempCanvas.toDataURL('image/png') // PNG sempre per trasparenza
                            : annotationData.drawing; // Usa l'originale se qualità massima
                        
                        // Crea una copia compressa dell'annotazione
                        const compressedAnnotation = {
                            ...annotationData,
                            drawing: compressedData,
                            // Rimuovi la history per ridurre ulteriormente la dimensione
                            drawingHistory: []
                        };
                        
                        resolve(compressedAnnotation);
                    };
                    img.src = annotationData.drawing;
                });
            }

            // --- Annotations List ---
            showAnnotationsList() {
                if (!this.currentPdf || !this.pdfDoc) {
                    this.showToast('Apri un PDF per vedere le annotazioni.', 'warning');
                    return;
                }
                const pdfId = this.currentPdf.id;
                const numPages = this.pdfDoc.numPages;
                const pagesWithAnnotations = [];
                
                // (RIMOSSO) Toast di debug per smartphone
                // this.showToast(`DEBUG: PDF ${pdfId}, Pagine: ${numPages}, Annotazioni in memoria: ${Object.keys(this.annotationState.currentPageAnnotations).length}`, 'info', 3000);
                
                for (let pageNum = 1; pageNum <= numPages; pageNum++) {
                    const key = `pdf_${pdfId}_${pageNum}`;
                    const data = this.annotationState.currentPageAnnotations[key];
                    // Filtro: solo annotazioni con almeno una nota non vuota o un disegno effettivo
                    let hasValidDrawing = false;
                    let hasValidNotes = false;
                    if (data) {
                        // Verifica se il disegno contiene effettivamente del contenuto
                        if (data.drawing && typeof data.drawing === 'string' && data.drawing.length > 100) {
                            // PNG vuoto: pattern base64 di un canvas vuoto 1x1 o simili
                            const isMinimalPNG = data.drawing.includes('iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVR42mNkYPhfDwAChwGA60e6kgAAAABJRU5ErkJggg==') ||
                                               data.drawing.includes('gQICAIaADBAgQIEAgLPCw+QLY1j9QigAAAABJRU5ErkJggg==');
                            hasValidDrawing = !isMinimalPNG;
                        }
                        // Verifica se ci sono note con contenuto effettivo
                        if (data.notes && Array.isArray(data.notes)) {
                            hasValidNotes = data.notes.some(note => note.content && note.content.trim() !== '');
                        }
                    }
                    if (hasValidDrawing || hasValidNotes) {
                        pagesWithAnnotations.push({
                            pageNum,
                            pageKey: key
                        });
                    }
                }
                
                pagesWithAnnotations.sort((a, b) => a.pageNum - b.pageNum);
                // (RIMOSSO) Toast di debug finale
                // this.showToast(`DEBUG: Pagine con annotazioni: ${pagesWithAnnotations.map(p => p.pageNum).join(', ')}`, 'info', 3000);
                
                if (pagesWithAnnotations.length === 0) {
                    this.showToast('Nessuna annotazione trovata in questo PDF.', 'info');
                } else {
                    this.showAnnotationsModal(pagesWithAnnotations);
                }
            }

            loadPageAnnotations() {
                const pageKey = this.getCurrentPageKey();
                const annotations = this.annotationState.currentPageAnnotations[pageKey];
                
                if (annotations) {
                    // Load drawing
                    if (annotations.drawing) {
                        const img = new Image();
                        img.onload = () => {
                            this.annotationState.drawingCtx.clearRect(0, 0, this.drawingCanvas.width, this.drawingCanvas.height);
                            this.annotationState.drawingCtx.drawImage(img, 0, 0);
                            // Imposta il flag se non ci sono operazioni di disegno in sessione
                            if (!annotations.drawingHistory || annotations.drawingHistory.length === 0) {
                                this.annotationState.hasImportedDrawing = true;
                                this.annotationState.hasImportedDrawingUnderSession = false;
                            }
                        };
                        img.src = annotations.drawing;
                    }
                    
                    // Load drawing history
                    if (annotations.drawingHistory) {
                        this.annotationState.drawingHistory = annotations.drawingHistory;
                        // Se ci sono operazioni di disegno in sessione, controlla se ci sono schizzi importati sotto
                        if (annotations.drawing && annotations.drawingHistory.length > 0) {
                            // Se c'è sia drawing che drawingHistory, significa che ci sono schizzi importati sotto
                            this.annotationState.hasImportedDrawing = true;
                            this.annotationState.hasImportedDrawingUnderSession = true;
                        } else {
                            this.annotationState.hasImportedDrawing = false;
                            this.annotationState.hasImportedDrawingUnderSession = false;
                        }
                    } else {
                        this.annotationState.drawingHistory = [];
                    }
                    
                    // Load sticky notes
                    this.clearStickyNotes();
                    if (annotations.notes) {
                        annotations.notes.forEach(noteData => {
                            this.createStickyNoteFromData(noteData);
                        });
                    }
                } else {
                    // Se non ci sono annotazioni in memoria, non eliminare quelle esistenti
                    // Mantieni lo stato attuale del canvas e delle note
                    // Solo se il canvas è vuoto e non ci sono note, allora pulisci tutto
                    const canvasHasContent = this.drawingCanvas.width > 0 && this.drawingCanvas.height > 0;
                    const hasStickyNotes = this.annotationState.stickyNotes.length > 0;
                    
                    if (!canvasHasContent && !hasStickyNotes) {
                        // Solo se non c'è nulla, pulisci tutto
                        this.clearAnnotations();
                    }
                }
            }

            clearStickyNotes() {
                this.annotationState.stickyNotes.forEach(note => note.remove());
                this.annotationState.stickyNotes = [];
            }

            clearAnnotations() {
                this.annotationState.drawingCtx.clearRect(0, 0, this.drawingCanvas.width, this.drawingCanvas.height);
                this.annotationState.drawingHistory = [];
                this.annotationState.hasImportedDrawing = false;
                this.annotationState.hasImportedDrawingUnderSession = false;
                this.clearStickyNotes();
            }

            async saveAnnotationsToStorage() {
                try {
                    const db = await this.openDB();
                    const transaction = db.transaction(['annotations'], 'readwrite');
                    const store = transaction.objectStore('annotations');
                    
                    const annotationsData = {
                        id: this.getCurrentPageKey(),
                        data: this.annotationState.currentPageAnnotations[this.getCurrentPageKey()],
                        timestamp: Date.now()
                    };
                    
                    await new Promise((resolve, reject) => {
                        const req = store.put(annotationsData);
                        req.onsuccess = () => resolve();
                        req.onerror = () => reject(req.error);
                    });
                } catch (error) {
                    console.error('Error saving annotations:', error);
                }
            }

            async loadAnnotationsFromStorage() {
                try {
                    const db = await this.openDB();
                    const transaction = db.transaction(['annotations'], 'readonly');
                    const store = transaction.objectStore('annotations');
                    
                    const annotations = await new Promise((resolve, reject) => {
                        const req = store.getAll();
                        req.onsuccess = () => resolve(req.result);
                        req.onerror = () => reject(req.error);
                    });
                    
                    annotations.forEach(annotation => {
                        this.annotationState.currentPageAnnotations[annotation.id] = annotation.data;
                    });
                    // Aggiorna subito l'elenco delle pagine modificate
                    this.updateModifiedPagesFromStorage();
                } catch (error) {
                    console.error('Error loading annotations:', error);
                }
            }

            // Handler placeholder per esportazione/importazione
            async exportAllData(selection) {
                try {
                    this.showLoading();
                    console.log('Inizio esportazione...');
                    if (typeof JSZip === 'undefined') {
                        throw new Error('JSZip non è disponibile');
                    }
                    const zip = new JSZip();
                    // 1. Salva i PDF (binari)
                    console.log('Salvataggio PDF...');
                    const pdfIds = selection?.pdfIds || this.pdfs.map(p => p.id);
                    for (const pdf of this.pdfs) {
                        if (!pdfIds.includes(pdf.id)) continue;
                        zip.file(`pdfs/${pdf.id}_${pdf.name}`, new Uint8Array(pdf.data));
                    }
                    // 2. Salva le annotazioni da IndexedDB come file separati (COMPRESSE)
                    console.log('Caricamento e compressione annotazioni...');
                    let annotationKeys = [];
                    try {
                        const db = await this.openDB();
                        console.log('Database aperto, leggo annotazioni...');
                        const tx = db.transaction('annotations', 'readonly');
                        const store = tx.objectStore('annotations');
                        const req = store.getAll();
                        const annotationsData = await new Promise((resolve, reject) => {
                            req.onsuccess = () => {
                                console.log('Annotazioni caricate:', req.result?.length || 0);
                                resolve(req.result || []);
                            };
                            req.onerror = () => {
                                console.error('Errore lettura annotazioni:', req.error);
                                reject(req.error);
                            };
                        });
                        // Comprimi ogni annotazione prima di salvarla
                        for (const entry of annotationsData) {
                            // Filtra annotazioni solo per eventi selezionati
                            let keep = false;
                            if (selection) {
                                // id annotazione: pdf_..._N oppure event_..._N
                                if (entry.id.startsWith('pdf_')) {
                                    // PDF: esporta solo se il PDF è selezionato
                                    const pdfId = entry.id.split('_')[1];
                                    if (pdfIds.includes(pdfId)) keep = true;
                                } else if (entry.id.startsWith('event_')) {
                                    // Eventi: esporta solo se l'evento è selezionato
                                    const eventId = entry.id.split('_')[1];
                                    if ((selection.eventIds||[]).includes(eventId)) keep = true;
                                }
                            } else {
                                keep = true;
                            }
                            if (!keep) continue;
                            annotationKeys.push(entry.id);
                            // Mostra progresso della compressione
                            const progress = Math.round((annotationKeys.length / annotationsData.length) * 100);
                            this.showToast(`Compressione annotazioni: ${progress}%`, 'secondary', 1000);
                            // Comprimi l'annotazione per l'esportazione
                            const compressedData = await this.compressAnnotationForExport(entry.data);
                            zip.file(`annotations/${entry.id}.json`, JSON.stringify(compressedData));
                        }
                    } catch (error) {
                        console.warn('Errore nel caricamento annotazioni:', error);
                    }
                    // 3. Salva eventi, cartelle, metadati e lista annotazioni in JSON
                    console.log('Creazione JSON di esportazione...');
                    const folderIds = selection?.folderIds || this.folders.map(f => f.id);
                    const eventIds = selection?.eventIds || this.events.map(e => e.id);
                    const exportJson = {
                        events: this.events.filter(ev => eventIds.includes(ev.id)),
                        folders: this.folders.filter(f => folderIds.includes(f.id)),
                        pdfs: this.pdfs.filter(pdf => pdfIds.includes(pdf.id)).map(pdf => ({
                            id: pdf.id,
                            name: pdf.name,
                            size: pdf.size,
                            pages: pdf.pages,
                            uploadDate: pdf.uploadDate
                        })),
                        annotationKeys: annotationKeys
                    };
                    zip.file('canzoniere_data.json', JSON.stringify(exportJson, null, 2));
                    // 4. Genera e scarica lo ZIP
                    console.log('Generazione ZIP...');
                    const blob = await zip.generateAsync({ type: 'blob' });
                    const url = URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    a.href = url;
                    const now = new Date();
                    const pad = n => n.toString().padStart(2, '0');
                    const dateStr = `${pad(now.getDate())}-${pad(now.getMonth()+1)}-${now.getFullYear()}_${pad(now.getHours())}-${pad(now.getMinutes())}`;
                    a.download = `Backup App Liste Canzoniere_${dateStr}.zip`;
                    document.body.appendChild(a);
                    a.click();
                    setTimeout(() => {
                        document.body.removeChild(a);
                        URL.revokeObjectURL(url);
                    }, 100);
                    console.log('Esportazione completata');
                    this.showToast('Backup esportato con successo!');
                } catch (err) {
                    console.error('Errore esportazione:', err);
                    this.showToast('Errore durante l\'esportazione!', 'error');
                } finally {
                    this.hideLoading();
                }
            }
            async importAllData(e) {
                const file = e.target.files[0];
                if (!file) return;
                this.showLoading();
                try {
                    const zip = await JSZip.loadAsync(file);
                    // 1. Leggi il JSON
                    const jsonFile = zip.file('canzoniere_data.json');
                    if (!jsonFile) throw new Error('File dati mancante nello ZIP!');
                    const jsonText = await jsonFile.async('string');
                    const data = JSON.parse(jsonText);
                    
                    // 2. Leggi i PDF
                    const pdfs = [];
                    for (const pdfMeta of data.pdfs) {
                        const pdfZipFile = zip.file(`pdfs/${pdfMeta.id}_${pdfMeta.name}`);
                        if (!pdfZipFile) continue;
                        const arrayBuffer = await pdfZipFile.async('arraybuffer');
                        pdfs.push({
                            ...pdfMeta,
                            data: arrayBuffer
                        });
                    }
                    
                    // 3. Aggiorna lo stato dell'app e IndexedDB
                    this.pdfs = pdfs;
                    this.events = data.events || [];
                    
                    // 4. Importa le annotazioni (sia dal campo JSON che dai file separati)
                    const db = await this.openDB();
                    // Prima cancella tutte le annotazioni esistenti
                    await new Promise((resolve, reject) => {
                        const tx = db.transaction('annotations', 'readwrite');
                        const store = tx.objectStore('annotations');
                        const clearReq = store.clear();
                        clearReq.onsuccess = () => resolve();
                        clearReq.onerror = () => reject(clearReq.error);
                    });
                    let importedCount = 0;
                    // a) Dal campo JSON (vecchio formato)
                    if (data.annotations) {
                        for (const [pageKey, annotationData] of Object.entries(data.annotations)) {
                            try {
                                await new Promise((resolve, reject) => {
                                    const tx = db.transaction('annotations', 'readwrite');
                                    const store = tx.objectStore('annotations');
                                    const req = store.put({
                                        id: pageKey,
                                        data: annotationData,
                                        timestamp: Date.now()
                                    });
                                    req.onsuccess = () => resolve();
                                    req.onerror = () => reject(req.error);
                                });
                                importedCount++;
                            } catch (err) {
                                console.warn('Errore import annotazione JSON:', pageKey, err);
                            }
                        }
                    }
                    // b) Dai file nella cartella 'annotations/' (nuovo formato)
                    const annotationFiles = Object.keys(zip.files).filter(name => name.startsWith('annotations/') && name.endsWith('.json'));
                    for (const fileName of annotationFiles) {
                        const pageKey = fileName.replace('annotations/', '').replace('.json', '');
                        const file = zip.file(fileName);
                        if (file) {
                            try {
                                const annotationData = JSON.parse(await file.async('string'));
                                await new Promise((resolve, reject) => {
                                    const tx = db.transaction('annotations', 'readwrite');
                                    const store = tx.objectStore('annotations');
                                    const req = store.put({
                                        id: pageKey,
                                        data: annotationData,
                                        timestamp: Date.now()
                                    });
                                    req.onsuccess = () => resolve();
                                    req.onerror = () => reject(req.error);
                                });
                                importedCount++;
                            } catch (err) {
                                console.warn('Errore import annotazione file:', fileName, err);
                            }
                        }
                    }
                    // Ricarica le annotazioni in memoria
                    await this.loadAnnotationsFromStorage();
                    // Se l'utente è già in visualizzazione PDF, ricarica le annotazioni della pagina corrente
                    if (this.pdfViewer.style.display !== 'none' && this.currentPdf) {
                        this.loadStickyNotesForCurrentPage();
                        this.loadDrawingForCurrentPage();
                        this.forceCanvasVisibility();
                    }
                    await this.saveData();
                    this.renderUI();
                    this.showToast(`Backup importato con successo! Annotazioni importate: ${importedCount}`);
                } catch (err) {
                    console.error('Errore importazione:', err);
                    this.showToast('Errore durante l\'importazione! ' + (err && err.message ? err.message : ''), 'error');
                } finally {
                    this.hideLoading();
                    e.target.value = '';
                }
            }

            // --- Funzione di utilità per coordinate corrette su canvas ---
            getCanvasRelativeCoords(e) {
                const rect = this.drawingCanvas.getBoundingClientRect();
                let clientX, clientY;
                if (e.touches && e.touches.length > 0) {
                    clientX = e.touches[0].clientX;
                    clientY = e.touches[0].clientY;
                } else {
                    clientX = e.clientX;
                    clientY = e.clientY;
                }
                // Calcola il rapporto tra dimensione reale e dimensione visuale
                const scaleX = this.drawingCanvas.width / rect.width;
                const scaleY = this.drawingCanvas.height / rect.height;
                return {
                    x: (clientX - rect.left) * scaleX,
                    y: (clientY - rect.top) * scaleY
                };
            }

            // Carica solo le sticky note per la pagina corrente
            loadStickyNotesForCurrentPage() {
                const pageKey = this.getCurrentPageKey();
                const annotations = this.annotationState.currentPageAnnotations[pageKey];
                this.clearStickyNotes();
                if (annotations && annotations.notes) {
                    annotations.notes.forEach(noteData => {
                        this.createStickyNoteFromData(noteData);
                    });
                }
            }

            // Carica solo il disegno per la pagina corrente
            loadDrawingForCurrentPage() {
                const pageKey = this.getCurrentPageKey();
                const annotations = this.annotationState.currentPageAnnotations[pageKey];
                console.log('[DEBUG] Caricamento disegno per', pageKey, annotations);
                if (annotations && annotations.drawing) {
                    if (typeof annotations.drawing !== 'string' || annotations.drawing.length < 30) {
                        console.warn('[DEBUG] drawing non valido o troppo corto:', annotations.drawing);
                        this.annotationState.drawingCtx.clearRect(0, 0, this.drawingCanvas.width, this.drawingCanvas.height);
                        this.drawingCanvas.classList.remove('active');
                        this.annotationState.hasImportedDrawing = false;
                        this.annotationState.hasImportedDrawingUnderSession = false;
                        return;
                    }
                    const img = new Image();
                    img.onload = () => {
                        console.log('[DEBUG] Disegno caricato correttamente per', pageKey);
                        this.annotationState.drawingCtx.clearRect(0, 0, this.drawingCanvas.width, this.drawingCanvas.height);
                        this.annotationState.drawingCtx.drawImage(img, 0, 0);
                        this.drawingCanvas.classList.add('active');
                        // Imposta il flag se non ci sono operazioni di disegno in sessione
                        if (!annotations.drawingHistory || annotations.drawingHistory.length === 0) {
                            this.annotationState.hasImportedDrawing = true;
                            this.annotationState.hasImportedDrawingUnderSession = false;
                        }
                    };
                    img.onerror = (e) => {
                        console.error('[DEBUG] Errore caricamento immagine drawing:', annotations.drawing, e);
                        this.annotationState.drawingCtx.clearRect(0, 0, this.drawingCanvas.width, this.drawingCanvas.height);
                        this.drawingCanvas.classList.remove('active');
                        this.annotationState.hasImportedDrawing = false;
                        this.annotationState.hasImportedDrawingUnderSession = false;
                    };
                    img.src = annotations.drawing;
                } else {
                    this.annotationState.drawingCtx.clearRect(0, 0, this.drawingCanvas.width, this.drawingCanvas.height);
                    this.drawingCanvas.classList.remove('active');
                    this.annotationState.hasImportedDrawing = false;
                    this.annotationState.hasImportedDrawingUnderSession = false;
                }
                // Carica anche la history se serve
                if (annotations && annotations.drawingHistory) {
                    this.annotationState.drawingHistory = annotations.drawingHistory;
                    // Se ci sono operazioni di disegno in sessione, controlla se ci sono schizzi importati sotto
                    if (annotations.drawing && annotations.drawingHistory.length > 0) {
                        // Se c'è sia drawing che drawingHistory, significa che ci sono schizzi importati sotto
                        this.annotationState.hasImportedDrawing = true;
                        this.annotationState.hasImportedDrawingUnderSession = true;
                    } else {
                        this.annotationState.hasImportedDrawing = false;
                        this.annotationState.hasImportedDrawingUnderSession = false;
                    }
                } else {
                    this.annotationState.drawingHistory = [];
                }
            }

            // --- INDICIZZAZIONE E RICERCA RAPIDA PDF ---
            async loadSearchIndex() {
                this.searchIndex = {};
                try {
                    const db = await this.openDB();
                    const tx = db.transaction('searchIndex', 'readonly');
                    const store = tx.objectStore('searchIndex');
                    const req = store.getAll();
                    return new Promise((resolve) => {
                        req.onsuccess = () => {
                            if (req.result) {
                                req.result.forEach(entry => {
                                    this.searchIndex[entry.pdfId] = entry;
                                });
                            }
                            resolve();
                        };
                        req.onerror = () => resolve();
                    });
                } catch (e) {
                    return;
                }
            }

            async indexPdfText(pdfId) {
                // Estrae il testo da tutte le pagine e salva in IndexedDB
                const pdf = this.pdfs.find(p => p.id === pdfId);
                if (!pdf) return;
                const arrayBuffer = pdf.data;
                const loadingTask = pdfjsLib.getDocument({data: arrayBuffer});
                const pdfDoc = await loadingTask.promise;
                const numPages = pdfDoc.numPages;
                const pages = [];
                
                // Mostra progresso per pagine grandi
                if (numPages > 10) {
                    this.showToast(`Indicizzazione: 0/${numPages} pagine...`, 'secondary');
                }
                
                for (let i = 1; i <= numPages; i++) {
                    const page = await pdfDoc.getPage(i);
                    const content = await page.getTextContent();
                    const text = content.items.map(item => item.str).join(' ');
                    pages.push({ page: i, text });
                    
                    // Aggiorna progresso ogni 10 pagine per PDF grandi
                    if (numPages > 10 && i % 10 === 0) {
                        this.showToast(`Indicizzazione: ${i}/${numPages} pagine...`, 'secondary');
                    }
                }
                
                const entry = { pdfId, pages };
                // Salva in IndexedDB
                const db = await this.openDB();
                const tx = db.transaction('searchIndex', 'readwrite');
                const store = tx.objectStore('searchIndex');
                store.put(entry);
                this.searchIndex[pdfId] = entry;
            }

            async removeSearchIndex(pdfId) {
                const db = await this.openDB();
                const tx = db.transaction('searchIndex', 'readwrite');
                const store = tx.objectStore('searchIndex');
                store.delete(pdfId);
                delete this.searchIndex[pdfId];
            }

            async reindexAllPdfs() {
                if (this.pdfs.length === 0) {
                    this.showToast('Nessun PDF da indicizzare', 'warning');
                    return;
                }
                const reindexBtn = document.getElementById('reindexPdfsBtn');
                const originalText = reindexBtn.innerHTML;
                reindexBtn.innerHTML = '<i class="fas fa-spinner fa-spin"></i> Indicizzazione...';
                reindexBtn.disabled = true;
                try {
                    this.showToast('Inizio indicizzazione PDF...', 'secondary');
                    let successCount = 0;
                    let errorCount = 0;
                    for (const pdf of this.pdfs) {
                        try {
                            await this.indexPdfText(pdf.id);
                            successCount++;
                        } catch (error) {
                            console.error(`Errore nell'indicizzazione di ${pdf.name}:`, error);
                            errorCount++;
                        }
                    }
                    if (errorCount === 0) {
                        this.showToast(`Indicizzazione completata! ${successCount} PDF indicizzati.`, 'success');
                    } else {
                        this.showToast(`Indicizzazione completata con errori: ${successCount} successi, ${errorCount} errori.`, 'warning');
                    }
                } catch (error) {
                    console.error('Errore durante la re-indicizzazione:', error);
                    this.showToast('Errore durante l\'indicizzazione', 'error');
                } finally {
                    reindexBtn.innerHTML = originalText;
                    reindexBtn.disabled = false;
                }
            }

            async autoIndexExistingPdfs() {
                // Indicizza solo i PDF che non hanno già un indice
                const unindexedPdfs = this.pdfs.filter(pdf => !this.searchIndex[pdf.id]);
                if (unindexedPdfs.length > 0) {
                    this.showToast(`Indicizzazione automatica di ${unindexedPdfs.length} PDF esistenti...`, 'secondary');
                    for (const pdf of unindexedPdfs) {
                        try {
                            await this.indexPdfText(pdf.id);
                            console.log(`PDF "${pdf.name}" indicizzato automaticamente.`);
                        } catch (error) {
                            console.error(`Errore nell'indicizzazione automatica di ${pdf.name}:`, error);
                        }
                    }
                    this.showToast('Indicizzazione automatica completata!', 'success');
                }
            }

            hideZoomIndicator() {
                clearTimeout(this.gestureState.zoomIndicatorTimeout);
                this.zoomIndicator.classList.remove('show');
            }

            showRecenterHint() {
                if (this.recenterHint) {
                    this.recenterHint.style.opacity = '1';
                    setTimeout(() => {
                        this.recenterHint.style.opacity = '0';
                    }, 3000);
                }
            }

            hideRecenterHint() {
                if (this.recenterHint) {
                    this.recenterHint.style.opacity = '0';
                }
            }

            handleTwoFingerTap(e) {
                // Ricentra la pagina con tap a due dita
                if (e.touches.length === 2) {
                    this.zoomLevel = 1;
                    this.pan = { x: 0, y: 0 };
                    this.renderCurrentPage();
                    this.updateViewerInfo();
                    // this.showToast('Pagina centrata', 'info', 1500);
                    e.preventDefault();
                }
            }

            startAutoSaveAnnotations() {
                if (this._autoSaveInterval) return;
                this._autoSaveInterval = setInterval(() => {
                    this.savePageAnnotations();
                    // Nessuna notifica qui - salvataggio silenzioso
                }, 5000);
            }

            stopAutoSaveAnnotations() {
                if (this._autoSaveInterval) {
                    clearInterval(this._autoSaveInterval);
                    this._autoSaveInterval = null;
                }
            }

            // Forza la visibilità del canvas se ci sono disegni sulla pagina corrente
            forceCanvasVisibility() {
                const pageKey = this.getCurrentPageKey();
                const annotations = this.annotationState.currentPageAnnotations[pageKey];
                if (annotations && annotations.drawing) {
                    this.drawingCanvas.classList.add('active');
                }
            }

            // --- INDICIZZAZIONE E RICERCA RAPIDA PDF ---
            deletePageAnnotations(pageKey, pageNum) {
                if (confirm(`Sei sicuro di voler eliminare tutte le annotazioni della pagina ${pageNum}?`)) {
                    // Rimuovi dal localStorage
                    delete this.annotationState.currentPageAnnotations[pageKey];
                    // Rimuovi da modifiedPages
                    if (this.currentPdf) {
                        const pdfId = this.currentPdf.id;
                        this.annotationState.modifiedPages.delete(`${pdfId}_${pageNum}`);
                    }
                    // Rimuovi da IndexedDB
                    this.deleteAnnotationFromStorage(pageKey);
                    // Se la pagina eliminata è quella attualmente visualizzata, pulisci la vista
                    if (!this.isViewingEvent && this.currentPdf && this.currentPageNum === pageNum) {
                        this.clearAnnotations();
                    }
                    this.showToast(`Annotazioni della pagina ${pageNum} eliminate.`, 'success');
                }
            }

            showAnnotationsModal(pagesWithAnnotations) {
                // Rimuovi modal esistente se presente
                const existingModal = document.getElementById('annotationsModal');
                if (existingModal) {
                    existingModal.remove();
                }

                // Crea il modal
                const modal = document.createElement('div');
                modal.id = 'annotationsModal';
                modal.className = 'modal-overlay';
                modal.innerHTML = `
                    <div class="modal-content">
                        <div class="modal-header">
                            <h3>Pagine con Annotazioni</h3>
                            <button class="modal-close" onclick="this.closest('.modal-overlay').remove()">
                                <i class="fas fa-times"></i>
                            </button>
                        </div>
                        <div class="modal-body">
                            <div class="annotations-list">
                                ${pagesWithAnnotations.map(page => {
                                    return `
                                        <div class="annotation-item">
                                            <div class="annotation-info">
                                                <span class="page-number">Pagina ${page.pageNum}</span>
                                                <span class="annotation-types">Note e/o Disegni</span>
                                            </div>
                                            <div class="annotation-actions">
                                                <button class="btn btn-primary btn-sm" onclick="app.goToPage(${page.pageNum}); this.closest('.modal-overlay').remove();">
                                                    <i class="fas fa-eye"></i> Visualizza
                                                </button>
                                                <button class="btn btn-danger btn-sm" onclick="app.deletePageAnnotations('${page.pageKey}', ${page.pageNum}); this.closest('.annotation-item').remove();">
                                                    <i class="fas fa-trash"></i> Elimina
                                                </button>
                                            </div>
                                        </div>
                                    `;
                                }).join('')}
                            </div>
                        </div>
                    </div>
                `;

                // Aggiungi stili CSS per il modal
                const style = document.createElement('style');
                style.textContent = `
                    .modal-overlay {
                        position: fixed;
                        top: 0;
                        left: 0;
                        width: 100%;
                        height: 100%;
                        background: rgba(0, 0, 0, 0.5);
                        display: flex;
                        align-items: center;
                        justify-content: center;
                        z-index: 1000;
                        backdrop-filter: blur(5px);
                    }
                    
                    .modal-content {
                        background: white;
                        border-radius: 16px;
                        box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
                        max-width: 600px;
                        width: 90%;
                        max-height: 80vh;
                        overflow: hidden;
                        animation: modalSlideIn 0.3s ease-out;
                    }
                    
                    @keyframes modalSlideIn {
                        from {
                            opacity: 0;
                            transform: translateY(-20px) scale(0.95);
                        }
                        to {
                            opacity: 1;
                            transform: translateY(0) scale(1);
                        }
                    }
                    
                    .modal-header {
                        display: flex;
                        justify-content: space-between;
                        align-items: center;
                        padding: 20px 24px;
                        border-bottom: 1px solid #e2e8f0;
                        background: linear-gradient(135deg, #3B82F6, #2563eb);
                        color: white;
                    }
                    
                    .modal-header h3 {
                        margin: 0;
                        font-size: 1.2rem;
                        font-weight: 600;
                    }
                    
                    .modal-close {
                        background: none;
                        border: none;
                        color: white;
                        font-size: 1.2rem;
                        cursor: pointer;
                        padding: 8px;
                        border-radius: 8px;
                        transition: background 0.2s;
                    }
                    
                    .modal-close:hover {
                        background: rgba(255, 255, 255, 0.1);
                    }
                    
                    .modal-body {
                        padding: 24px;
                        max-height: 60vh;
                        overflow-y: auto;
                    }
                    
                    .annotations-list {
                        display: flex;
                        flex-direction: column;
                        gap: 12px;
                    }
                    
                    .annotation-item {
                        display: flex;
                        justify-content: space-between;
                        align-items: center;
                        padding: 16px;
                        background: #f8fafc;
                        border-radius: 12px;
                        border: 1px solid #e2e8f0;
                        transition: all 0.2s;
                    }
                    
                    .annotation-item:hover {
                        background: #f1f5f9;
                        transform: translateY(-1px);
                        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
                    }
                    
                    .annotation-info {
                        display: flex;
                        flex-direction: column;
                        gap: 4px;
                    }
                    
                    .page-number {
                        font-weight: 600;
                        color: #1e293b;
                        font-size: 1rem;
                    }
                    
                    .annotation-types {
                        color: #64748b;
                        font-size: 0.9rem;
                    }
                    
                    .annotation-actions {
                        display: flex;
                        gap: 8px;
                    }
                    
                    .btn-sm {
                        padding: 8px 12px;
                        font-size: 0.85rem;
                    }
                `;

                document.head.appendChild(style);
                document.body.appendChild(modal);

                // Chiudi modal cliccando fuori
                modal.addEventListener('click', (e) => {
                    if (e.target === modal) {
                        modal.remove();
                    }
                });
            }

            async deleteAnnotationFromStorage(pageKey) {
                try {
                    const db = await this.openDB();
                    const transaction = db.transaction(['annotations'], 'readwrite');
                    const store = transaction.objectStore('annotations');
                    
                    await new Promise((resolve, reject) => {
                        const req = store.delete(pageKey);
                        req.onsuccess = () => resolve();
                        req.onerror = () => reject(req.error);
                    });
                } catch (error) {
                    console.error('Error deleting annotation:', error);
                }
            }

            async indexCurrentPdf() {
                // Implementa l'indicizzazione del PDF attualmente aperto
                if (this.currentPdf) {
                    try {
                        await this.indexPdfText(this.currentPdf.id);
                        this.showToast('PDF indicizzato con successo!', 'success');
                    } catch (error) {
                        console.error('Errore durante l\'indicizzazione del PDF:', error);
                        this.showToast('Errore durante l\'indicizzazione del PDF', 'error');
                    }
                } else {
                    this.showToast('Nessun PDF aperto per l\'indicizzazione', 'warning');
                }
            }

            // --- ESPORTA PDF EVENTO (scaletta) ---
            async exportEventPdf() {
                const eventId = this.eventDetailModal.dataset.eventId;
                const event = this.events.find(e => e.id === eventId);
                if (!event || event.pages.length === 0) {
                    this.showToast('Nessuna pagina da esportare', 'warning');
                    return;
                }
                this.showLoading();
                // Mostra barra di progresso
                const progressBarWrapper = document.getElementById('pdfExportProgressBarWrapper');
                const progressBar = document.getElementById('pdfExportProgressBar');
                progressBarWrapper.style.display = 'block';
                progressBar.style.width = '0%';
                try {
                    const { jsPDF } = window.jspdf;
                    const pdf = new jsPDF();
                    let isFirstPage = true;
                    const total = event.pages.length;
                    let current = 0;
                    for (const pageInfo of event.pages) {
                        const pdfData = this.pdfs.find(p => p.id === pageInfo.pdfId);
                        if (!pdfData) continue;
                        const pdfDoc = await pdfjsLib.getDocument({ data: pdfData.data }).promise;
                        const page = await pdfDoc.getPage(pageInfo.pageNumber);
                        const viewport = page.getViewport({ scale: 2 });
                        const canvas = document.createElement('canvas');
                        const context = canvas.getContext('2d');
                        canvas.width = viewport.width;
                        canvas.height = viewport.height;
                        await page.render({ canvasContext: context, viewport: viewport }).promise;
                        const imgData = canvas.toDataURL('image/jpeg', 1.0);
                        const pageWidth = pdf.internal.pageSize.getWidth();
                        const pageHeight = pdf.internal.pageSize.getHeight();
                        const ratio = Math.min(pageWidth / canvas.width, pageHeight / canvas.height);
                        const imgW = canvas.width * ratio;
                        const imgH = canvas.height * ratio;
                        const x = (pageWidth - imgW) / 2;
                        const y = (pageHeight - imgH) / 2;
                        if (!isFirstPage) pdf.addPage();
                        pdf.addImage(imgData, 'JPEG', x, y, imgW, imgH);
                        isFirstPage = false;
                        current++;
                        progressBar.style.width = Math.round((current / total) * 100) + '%';
                    }
                    const fileName = `Scaletta_${event.name.replace(/[^a-zA-Z0-9]/g, '_')}.pdf`;
                    pdf.save(fileName);
                    this.showToast('PDF esportato con successo!', 'success');
                } catch (err) {
                    console.error('Errore esportazione PDF evento:', err);
                    this.showToast('Errore durante l\'esportazione PDF', 'error');
                } finally {
                    this.hideLoading();
                    // Nascondi barra di progresso
                    progressBarWrapper.style.display = 'none';
                    progressBar.style.width = '0%';
                }
            }

            // Ricostruisce l'elenco delle pagine modificate dalle annotazioni caricate da IndexedDB
            updateModifiedPagesFromStorage() {
                this.annotationState.modifiedPages = new Set();
                for (const key in this.annotationState.currentPageAnnotations) {
                    const data = this.annotationState.currentPageAnnotations[key];
                    if (data && (data.drawing || (data.notes && data.notes.length > 0))) {
                        this.annotationState.modifiedPages.add(key);
                    }
                }
            }

            // Pulizia automatica delle annotazioni orfane all'avvio e su richiesta
            async cleanOrphanAnnotations(showToast = true) {
                // Ottieni tutti gli id PDF validi
                const validPdfIds = new Set(this.pdfs.map(pdf => String(pdf.id)));
                // Ottieni tutte le annotazioni dal DB
                try {
                    const db = await this.openDB();
                    const transaction = db.transaction(['annotations'], 'readwrite');
                    const store = transaction.objectStore('annotations');
                    const req = store.getAllKeys();
                    const keys = await new Promise((resolve, reject) => {
                        req.onsuccess = () => resolve(req.result);
                        req.onerror = () => reject(req.error);
                    });
                    let removed = 0;
                    for (const key of keys) {
                        const match = key.match(/^pdf_([\w-]+)_(\d+)$/);
                        if (!match || !validPdfIds.has(match[1])) {
                            store.delete(key);
                            removed++;
                        }
                    }
                    // Pulisci anche la memoria
                    for (const key of Object.keys(this.annotationState.currentPageAnnotations)) {
                        const match = key.match(/^pdf_([\w-]+)_(\d+)$/);
                        if (!match || !validPdfIds.has(match[1])) {
                            delete this.annotationState.currentPageAnnotations[key];
                            this.annotationState.modifiedPages && this.annotationState.modifiedPages.delete(key);
                        }
                    }
                    if (showToast) {
                        this.showToast(removed > 0 ? `Annotazioni orfane rimosse: ${removed}` : 'Nessuna annotazione orfana trovata', 'success');
                    }
                } catch (error) {
                    this.showToast('Errore nella pulizia annotazioni orfane', 'error');
                }
            }

            // Wake Lock per mantenere lo schermo acceso durante la visualizzazione PDF
            async requestWakeLock() {
                try {
                    if ('wakeLock' in navigator) {
                        this.wakeLock = await navigator.wakeLock.request('screen');
                        console.log('Wake Lock attivato - lo schermo rimarrà acceso');
                        
                        // Gestisci il caso in cui il Wake Lock viene rilasciato automaticamente
                        this.wakeLock.addEventListener('release', () => {
                            console.log('Wake Lock rilasciato automaticamente');
                            this.wakeLock = null;
                        });
                    } else {
                        console.log('Wake Lock API non supportata su questo dispositivo');
                    }
                } catch (err) {
                    console.error('Errore nell\'attivazione del Wake Lock:', err);
                }
            }

            releaseWakeLock() {
                if (this.wakeLock) {
                    this.wakeLock.release();
                    this.wakeLock = null;
                    console.log('Wake Lock rilasciato - lo schermo può spegnersi normalmente');
                }
            }
        }

        // Initialize app
        let app;
        window.onload = () => {
            app = new CanzoniereApp();
            window.app = app; // Make app accessible globally for direct calls from HTML
        };

        // Service Worker Registration
        function registerServiceWorker() {
            if ('serviceWorker' in navigator) {
                navigator.serviceWorker.register('./sw.js')
                    .then(registration => {
                        console.log('[SW] Service Worker registrato con successo:', registration);
                        
                        // Controlla se c'è un aggiornamento disponibile
                        registration.addEventListener('updatefound', () => {
                            const newWorker = registration.installing;
                            newWorker.addEventListener('statechange', () => {
                                if (newWorker.state === 'installed' && navigator.serviceWorker.controller) {
                                    // Nuovo Service Worker disponibile
                                    if (confirm('È disponibile un aggiornamento dell\'app. Vuoi aggiornare ora?')) {
                                        newWorker.postMessage({ type: 'SKIP_WAITING' });
                                        window.location.reload();
                                    }
                                }
                            });
                        });
                    })
                    .catch(error => {
                        console.error('[SW] Registrazione Service Worker fallita:', error);
                    });
                
                // Ascolta i messaggi dal Service Worker
                navigator.serviceWorker.addEventListener('message', event => {
                    if (event.data && event.data.type === 'CACHE_UPDATED') {
                        console.log('[SW] Cache aggiornata');
                    }
                });
            }
        }
    </script>
    <div id="pdfExportProgressBarWrapper"><div id="pdfExportProgressBar"></div></div>
    <div id="zipExportProgressBarWrapper"><div id="zipExportProgressBar"></div></div>
    <div id="zipExportManualLink"></div>
</body>
</html>